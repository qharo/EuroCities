<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Urban Accessibility Dashboard</title>

        <!-- External Libraries -->
        <script src="https://cdn.tailwindcss.com"></script>
        <link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css"
        />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.heat/0.2.0/leaflet-heat.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.js"></script>

        <style>
            .leaflet-container {
                height: 100%;
                width: 100%;
            }
            .info {
                padding: 6px 8px;
                font: 14px/16px Arial, Helvetica, sans-serif;
                background: rgba(255, 255, 255, 0.8);
                box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
                border-radius: 5px;
            }
            .legend {
                line-height: 18px;
                color: #555;
            }
            .legend i {
                width: 18px;
                height: 18px;
                float: left;
                margin-right: 8px;
                opacity: 0.7;
            }
            .search-results {
                max-height: 200px;
                overflow-y: auto;
            }
        </style>
    </head>

    <body class="bg-gray-100">
        <div class="min-h-screen flex flex-col">
            <!-- Header -->
            <header class="bg-blue-600 text-white p-4 shadow-md">
                <div class="container mx-auto">
                    <h1 class="text-2xl font-bold">
                        Urban Accessibility Dashboard
                    </h1>
                </div>
            </header>

            <!-- Main Content -->
            <main class="flex-grow flex flex-col md:flex-row">
                <!-- Map Column -->
                <div class="w-full md:w-3/5 h-[70vh] md:h-screen relative">
                    <div
                        id="loading"
                        class="absolute inset-0 bg-white bg-opacity-90 z-50 flex items-center justify-center"
                    >
                        <div class="text-center p-4">
                            <div
                                class="spinner-border inline-block w-8 h-8 border-4 border-t-blue-500 border-r-transparent border-b-blue-500 border-l-transparent rounded-full animate-spin mb-4"
                            ></div>
                            <p class="text-gray-700">
                                Select a city to view the visualization
                            </p>
                        </div>
                    </div>

                    <div id="map" class="h-full"></div>
                </div>

                <!-- Metrics Column -->
                <div class="w-full md:w-2/5 p-4 overflow-auto h-screen">
                    <!-- Search Box -->
                    <div class="bg-white rounded-lg shadow-md p-4 mb-4">
                        <h4 class="font-bold text-gray-700 mb-2">
                            Search City
                        </h4>
                        <div class="relative">
                            <input
                                type="text"
                                id="city-search"
                                placeholder="Type to search..."
                                class="w-full p-2 border border-gray-300 rounded"
                            />
                            <div
                                id="search-results"
                                class="absolute left-0 right-0 mt-1 bg-white rounded shadow-lg hidden search-results z-50"
                            >
                                <!-- Search results will appear here -->
                            </div>
                        </div>
                        <div
                            id="selected-city"
                            class="mt-2 text-xs text-gray-500 text-center"
                        >
                            No city selected
                        </div>
                    </div>

                    <!-- Visualization Options -->
                    <div class="bg-white rounded-lg shadow-md p-4 mb-4">
                        <h4 class="font-bold text-gray-700 mb-2">
                            Visualization Options
                        </h4>
                        <div class="flex flex-col space-y-2">
                            <div class="grid grid-cols-2 gap-2">
                                <button
                                    id="distance-btn"
                                    class="px-3 py-1 text-sm rounded border border-gray-300 bg-blue-500 text-white hover:bg-blue-600 transition"
                                >
                                    Distance to Transit
                                </button>
                                <button
                                    id="modes-btn"
                                    class="px-3 py-1 text-sm rounded border border-gray-300 bg-white hover:bg-gray-100 transition"
                                >
                                    Transit Mode Variety
                                </button>
                            </div>

                            <div class="flex items-center mt-1">
                                <input
                                    type="checkbox"
                                    id="show-stops"
                                    class="mr-2"
                                    checked
                                />
                                <label for="show-stops" class="text-sm"
                                    >Show Transit Stops</label
                                >
                            </div>

                            <div class="flex items-center mt-1">
                                <input
                                    type="checkbox"
                                    id="show-age"
                                    class="mr-2"
                                />
                                <label for="show-age" class="text-sm"
                                    >Show Building Age</label
                                >
                            </div>

                            <!-- Removed dot radius slider -->
                        </div>
                    </div>

                    <div class="bg-white rounded-lg shadow-md p-4 mb-4">
                        <h2 class="text-xl font-bold text-gray-800 mb-3">
                            City Metrics
                        </h2>
                        <div id="city-metrics" class="text-gray-600">
                            <p class="text-center text-gray-400">
                                Select a city to see metrics
                            </p>
                        </div>
                    </div>

                    <div class="bg-white rounded-lg shadow-md p-4 mb-4">
                        <h2 class="text-xl font-bold text-gray-800 mb-3">
                            Transit Accessibility
                        </h2>
                        <div class="h-64">
                            <canvas id="transit-chart"></canvas>
                        </div>
                    </div>

                    <div class="bg-white rounded-lg shadow-md p-4 mb-4">
                        <h2 class="text-xl font-bold text-gray-800 mb-3">
                            Transport Mode Distribution
                        </h2>
                        <div class="h-64">
                            <canvas id="mode-chart"></canvas>
                        </div>
                    </div>

                    <div class="bg-white rounded-lg shadow-md p-4">
                        <h2 class="text-xl font-bold text-gray-800 mb-3">
                            Building Age Distribution
                        </h2>
                        <div class="h-64">
                            <canvas id="age-chart"></canvas>
                        </div>
                    </div>
                </div>
            </main>
        </div>

        <script>
            const cityData = [
                {
                    name: "Paris",
                    geojsonUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/ef2165a6d5654ae6ea9063f78af99a71583a1990/Cities/Paris/paris.geojson",
                    metricsUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/ef2165a6d5654ae6ea9063f78af99a71583a1990/Cities/Paris/paris_city_metrics.json",
                },
                {
                    name: "Lyon",
                    geojsonUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Lyon/lyon.geojson",
                    metricsUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Lyon/lyon_city_metrics.json",
                },
                {
                    name: "Marseille",
                    geojsonUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Marseille/marseille.geojson",
                    metricsUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Marseille/marseille_city_metrics.json",
                },
                {
                    name: "Toulouse",
                    geojsonUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Toulouse/toulouse.geojson",
                    metricsUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Toulouse/toulouse_city_metrics.json",
                },
                {
                    name: "Milan",
                    geojsonUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Milan/milan.geojson",
                    metricsUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Milan/milan_city_metrics.json",
                },
                {
                    name: "Munich",
                    geojsonUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Munich/munich.geojson",
                    metricsUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Munich/munich_city_metrics.json",
                },
                {
                    name: "Nice",
                    geojsonUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Nice/nice.geojson",
                    metricsUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Nice/nice_city_metrics.json",
                },
                {
                    name: "Rome",
                    geojsonUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Rome/rome.geojson",
                    metricsUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Rome/rome_city_metrics.json",
                },
            ];

            // Variables for our global data and layers
            let map, info, distanceLegend, modesLegend, ageLegend;
            let buildingsLayer, stopsLayer, buildingAgeLayer;
            let currentMode = "distance"; // Default view
            let geoJsonData; // Will store our GeoJSON data
            let ageDistributionData; // Will store building age distribution
            let cityMetricsData;
            let transitPointsData; // Will store transit points info

            // Init map
            initMap();
            setupSearchAutocomplete();
            setupEventListeners();

            // Initialize the map
            function initMap() {
                map = L.map("map").setView([46.603354, 1.888334], 6); // Center on France

                L.tileLayer(
                    "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
                    {
                        maxZoom: 19,
                        attribution:
                            '&copy; <a href="https://openstreetmap.org/copyright">OpenStreetMap contributors</a>',
                    }
                ).addTo(map);

                // Initialize info control
                info = createInfoControl();
                info.addTo(map);

                // Initialize legends
                distanceLegend = createLegend("distance");
                modesLegend = createLegend("modes");
                ageLegend = createLegend("age");
            }

            // Initialize the search autocomplete
            function setupSearchAutocomplete() {
                const searchInput = document.getElementById("city-search");
                const searchResults = document.getElementById("search-results");

                searchInput.addEventListener("input", function () {
                    const query = this.value.toLowerCase();
                    if (query.length < 2) {
                        searchResults.classList.add("hidden");
                        return;
                    }

                    const filteredCities = cityData.filter((city) =>
                        city.name.toLowerCase().includes(query)
                    );

                    if (filteredCities.length > 0) {
                        searchResults.innerHTML = "";
                        filteredCities.forEach((city) => {
                            const div = document.createElement("div");
                            div.className =
                                "p-2 hover:bg-gray-100 cursor-pointer";
                            div.textContent = city.name;
                            div.addEventListener("click", () => {
                                loadCity(city);
                                searchInput.value = city.name;
                                searchResults.classList.add("hidden");
                            });
                            searchResults.appendChild(div);
                        });
                        searchResults.classList.remove("hidden");
                    } else {
                        searchResults.classList.add("hidden");
                    }
                });

                // Close results when clicking outside
                document.addEventListener("click", function (e) {
                    if (
                        e.target !== searchInput &&
                        !searchResults.contains(e.target)
                    ) {
                        searchResults.classList.add("hidden");
                    }
                });
            }

            function sanitizeJSONString(jsonString) {
                // Replace NaN and Infinity values with null in JSON string
                return jsonString
                    .replace(/: *NaN/g, ": null")
                    .replace(/: *Infinity/g, ": null")
                    .replace(/: *-Infinity/g, ": null");
            }

            function loadCity(city) {
                document.getElementById(
                    "selected-city"
                ).textContent = `Selected: ${city.name}`;
                document.getElementById("loading").style.display = "flex";
                document.getElementById("loading").innerHTML = `
                    <div class="text-center p-4">
                        <div class="spinner-border inline-block w-8 h-8 border-4 border-t-blue-500 border-r-transparent border-b-blue-500 border-l-transparent rounded-full animate-spin mb-4"></div>
                        <p class="text-gray-700">Loading data for ${city.name}...</p>
                    </div>
                `;

                // Load GeoJSON data
                fetch(city.geojsonUrl)
                    .then((response) => {
                        if (!response.ok)
                            throw new Error(
                                `Error loading GeoJSON data for ${city.name}`
                            );
                        return response.text(); // Get as text first
                    })
                    .then((text) => {
                        // Sanitize JSON string by replacing NaN with null
                        const sanitizedText = sanitizeJSONString(text);
                        return JSON.parse(sanitizedText);
                    })
                    .then((data) => {
                        // Transform coordinates if needed
                        geoJsonData = transformGeoJSON(data);

                        // Load city metrics data
                        return fetch(city.metricsUrl)
                            .then((response) => {
                                if (!response.ok)
                                    throw new Error(
                                        `Error loading metrics for ${city.name}`
                                    );
                                return response.text(); // Get as text first
                            })
                            .then((text) => {
                                // Sanitize JSON string by replacing NaN with null
                                const sanitizedText = sanitizeJSONString(text);
                                return JSON.parse(sanitizedText);
                            })
                            .then((cityMetrics) => {
                                // Extract age distribution data from city metrics
                                ageDistributionData =
                                    cityMetrics.building_age_distribution || [];
                                cityMetricsData = cityMetrics;
                                return { geoJsonData, cityMetricsData };
                            })
                            .catch((error) => {
                                console.warn(
                                    "Could not load city metrics data:",
                                    error
                                );
                                ageDistributionData = [];
                                cityMetricsData = null;
                                return { geoJsonData, cityMetricsData: null };
                            });
                    })
                    .then((data) => {
                        document.getElementById("loading").style.display =
                            "none";

                        // Generate transit stops data
                        generateTransitPointsData(geoJsonData);

                        // Render visualizations
                        clearLayers();
                        toggleMode(currentMode);
                        createTransitStopsLayer();
                        displayCityMetrics();

                        // Fit map to data bounds
                        fitMapToBounds();

                        // Set up click handlers
                        setupMapClickHandler();
                    })
                    .catch((error) => {
                        console.error("Error loading city data:", error);
                        document.getElementById("loading").innerHTML = `
                            <div class="text-center p-4">
                                <p class="text-red-600">Error loading data: ${error.message}</p>
                            </div>
                        `;
                    });
            }

            // Transform coordinates from Lambert-93 to WGS84 if needed
            function transformGeoJSON(geojson) {
                // Define coordinate transformation from EPSG:2154 (Lambert 93) to WGS84
                proj4.defs(
                    "EPSG:2154",
                    "+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
                );
                proj4.defs("EPSG:4326", "+proj=longlat +datum=WGS84 +no_defs");

                // Create a deep clone of the GeoJSON
                const transformed = JSON.parse(JSON.stringify(geojson));

                // Check if coordinates need transformation (detect Lambert-93)
                const needsTransform = transformed.features.some((feature) => {
                    const coords = feature.geometry.coordinates;
                    return (
                        Array.isArray(coords) &&
                        coords.length === 2 &&
                        (coords[0] > 600000 || coords[1] > 6000000)
                    );
                });

                if (needsTransform) {
                    transformed.features.forEach((feature) => {
                        try {
                            const coords = feature.geometry.coordinates;
                            const transformedCoords = proj4(
                                "EPSG:2154",
                                "EPSG:4326",
                                coords
                            );
                            feature.geometry.coordinates = transformedCoords;
                        } catch (error) {
                            console.error("Transformation error:", error);
                        }
                    });
                }

                return transformed;
            }

            // Generate transit points data
            function generateTransitPointsData(data) {
                if (!data || !data.features || data.features.length === 0)
                    return;

                // Find buildings with shortest distances (likely closest to actual stops)
                const buildings = [...data.features];
                buildings.sort(
                    (a, b) =>
                        a.properties.transport_distance -
                        b.properties.transport_distance
                );

                // Use the closest ~5% of buildings as proxies for stops
                const stopCount = Math.max(
                    5,
                    Math.ceil(buildings.length * 0.05)
                );
                const transitPoints = [];
                const usedPositions = new Set();

                for (
                    let i = 0;
                    i < Math.min(stopCount, buildings.length);
                    i++
                ) {
                    const building = buildings[i];
                    const coords = building.geometry.coordinates;

                    // Create a simple hash of the position to avoid duplicates
                    const posKey = `${Math.round(
                        coords[0] * 1000
                    )},${Math.round(coords[1] * 1000)}`;

                    if (!usedPositions.has(posKey)) {
                        usedPositions.add(posKey);

                        // Assign transit type based on position
                        let type = "bus";
                        if (i % 4 === 0) type = "subway";
                        else if (i % 4 === 1) type = "bus";
                        else if (i % 4 === 2) type = "tram";
                        else type = "train";

                        transitPoints.push({
                            coords: coords,
                            type: type,
                        });
                    }
                }

                // Count by type
                const typeCounts = transitPoints.reduce((acc, point) => {
                    acc[point.type] = (acc[point.type] || 0) + 1;
                    return acc;
                }, {});

                transitPointsData = {
                    points: transitPoints,
                    totalCount: transitPoints.length,
                    typeCounts: typeCounts,
                };
            }

            // Clear existing layers
            function clearLayers() {
                if (buildingsLayer) map.removeLayer(buildingsLayer);
                if (buildingAgeLayer) map.removeLayer(buildingAgeLayer);
                if (stopsLayer) map.removeLayer(stopsLayer);
                map.removeControl(distanceLegend);
                map.removeControl(modesLegend);
                map.removeControl(ageLegend);
            }

            // Fit map to data bounds
            function fitMapToBounds() {
                if (
                    !geoJsonData ||
                    !geoJsonData.features ||
                    geoJsonData.features.length === 0
                )
                    return;

                const bounds = geoJsonData.features.reduce(
                    (bounds, feature) => {
                        const coords = feature.geometry.coordinates;
                        bounds.extend([coords[1], coords[0]]);
                        return bounds;
                    },
                    L.latLngBounds([])
                );

                if (bounds.isValid()) {
                    map.fitBounds(bounds);
                }
            }

            // Create info control for hovering
            function createInfoControl() {
                const info = L.control();

                info.onAdd = function () {
                    this._div = L.DomUtil.create("div", "info");
                    this.update();
                    return this._div;
                };

                info.update = function (props) {
                    this._div.innerHTML =
                        "<h4 class='font-bold mb-1'>Location Information</h4>" +
                        (props
                            ? `<b>Distance to transit:</b> ${Math.round(
                                  props.transit_distance
                              )} meters<br />` +
                              `<b>Transit modes within 100m:</b> ${props.transit_modes}<br />` +
                              (props.year_built && !isNaN(props.year_built)
                                  ? `<b>Built:</b> ${props.year_built} (${
                                        new Date().getFullYear() -
                                        props.year_built
                                    } years old)<br />`
                                  : "") +
                              (props.green_distance
                                  ? `<b>Distance to green space:</b> ${Math.round(
                                        props.green_distance
                                    )} meters<br />`
                                  : "")
                            : "Hover over the map");
                };

                return info;
            }

            // Create legend based on visualization mode
            function createLegend(type) {
                const legend = L.control({ position: "bottomright" });

                legend.onAdd = function () {
                    const div = L.DomUtil.create("div", "info legend");

                    if (type === "distance") {
                        const grades = [0, 100, 200, 400, 600, 800, 1000];
                        div.innerHTML =
                            "<h4 class='font-bold mb-2'>Distance to Transit (m)</h4>";

                        for (let i = 0; i < grades.length; i++) {
                            div.innerHTML +=
                                '<i style="background:' +
                                getDistanceColor(grades[i] + 1) +
                                '"></i> ' +
                                grades[i] +
                                (grades[i + 1]
                                    ? "&ndash;" + grades[i + 1] + " m<br>"
                                    : "+ m");
                        }
                    } else if (type === "modes") {
                        const grades = [0, 1, 2, 3, 4];
                        div.innerHTML =
                            "<h4 class='font-bold mb-2'>Transit Mode Variety</h4>";

                        for (let i = 0; i < grades.length; i++) {
                            div.innerHTML +=
                                '<i style="background:' +
                                getModesColor(grades[i]) +
                                '"></i> ' +
                                (grades[i] === 0
                                    ? "None"
                                    : grades[i] +
                                      (grades[i + 1]
                                          ? "&ndash;" + grades[i + 1] + "<br>"
                                          : "+"));
                        }
                    } else if (type === "age") {
                        const grades = [0, 10, 25, 50, 75, 100, 150, 200];
                        div.innerHTML =
                            "<h4 class='font-bold mb-2'>Building Age (years)</h4>";

                        for (let i = 0; i < grades.length; i++) {
                            const currentYear = new Date().getFullYear();
                            div.innerHTML +=
                                '<i style="background:' +
                                getAgeColor(currentYear - grades[i] - 1) +
                                '"></i> ' +
                                grades[i] +
                                (grades[i + 1]
                                    ? "&ndash;" + grades[i + 1] + "<br>"
                                    : "+");
                        }
                    }

                    return div;
                };

                return legend;
            }

            // Color scales for different metrics
            function getDistanceColor(d) {
                return d > 1000
                    ? "#d73027"
                    : d > 800
                    ? "#f46d43"
                    : d > 600
                    ? "#fdae61"
                    : d > 400
                    ? "#fee08b"
                    : d > 200
                    ? "#d9ef8b"
                    : d > 100
                    ? "#a6d96a"
                    : "#1a9850";
            }

            function getModesColor(d) {
                return d >= 4
                    ? "#08519c"
                    : d >= 3
                    ? "#3182bd"
                    : d >= 2
                    ? "#6baed6"
                    : d >= 1
                    ? "#9ecae1"
                    : "#deebf7";
            }

            function getAgeColor(year) {
                if (!year || isNaN(year)) return "#cccccc"; // No data

                const currentYear = new Date().getFullYear();
                const age = currentYear - year;

                return age > 200
                    ? "#67000d"
                    : age > 150
                    ? "#a50f15"
                    : age > 100
                    ? "#cb181d"
                    : age > 75
                    ? "#ef3b2c"
                    : age > 50
                    ? "#fb6a4a"
                    : age > 25
                    ? "#fc9272"
                    : age > 10
                    ? "#fcbba1"
                    : "#fee5d9";
            }

            // Toggle between visualization modes
            function toggleMode(mode) {
                currentMode = mode;

                // Remove existing layers and legends
                clearLayers();

                // Update button states
                document.getElementById("distance-btn").className =
                    "px-3 py-1 text-sm rounded border border-gray-300 bg-white hover:bg-gray-100 transition";
                document.getElementById("modes-btn").className =
                    "px-3 py-1 text-sm rounded border border-gray-300 bg-white hover:bg-gray-100 transition";

                // Add appropriate layer and legend based on mode
                if (mode === "distance") {
                    document.getElementById("distance-btn").className =
                        "px-3 py-1 text-sm rounded border border-gray-300 bg-blue-500 text-white hover:bg-blue-600 transition";
                    renderBuildingDots("distance");
                    distanceLegend.addTo(map);
                } else if (mode === "modes") {
                    document.getElementById("modes-btn").className =
                        "px-3 py-1 text-sm rounded border border-gray-300 bg-blue-500 text-white hover:bg-blue-600 transition";
                    renderBuildingDots("modes");
                    modesLegend.addTo(map);
                } else if (mode === "age") {
                    renderBuildingDots("age");
                    ageLegend.addTo(map);
                }

                // Update transit stops visibility
                toggleStops();
            }

            // Render buildings as colored dots
            function renderBuildingDots(mode) {
                if (
                    !geoJsonData ||
                    !geoJsonData.features ||
                    geoJsonData.features.length === 0
                )
                    return;

                if (buildingsLayer) map.removeLayer(buildingsLayer);
                if (buildingAgeLayer) map.removeLayer(buildingAgeLayer);

                const radius = 4; // Fixed dot radius

                // Create a canvas renderer for better performance with many dots
                const canvasRenderer = L.canvas({ padding: 0.5 });

                if (mode === "age") {
                    // Filter buildings with year data (changed from year to year_built)
                    const buildingsWithYear = geoJsonData.features.filter(
                        (feature) =>
                            feature.properties.year_built &&
                            !isNaN(feature.properties.year_built)
                    );

                    // Create a simplified GeoJSON with just the buildings that have year data
                    const ageGeoJson = {
                        type: "FeatureCollection",
                        features: buildingsWithYear,
                    };

                    // Create building age dots
                    buildingAgeLayer = L.geoJSON(ageGeoJson, {
                        renderer: canvasRenderer,
                        pointToLayer: function (feature, latlng) {
                            return L.circleMarker(latlng, {
                                radius: radius,
                                fillColor: getAgeColor(
                                    feature.properties.year_built
                                ), // Changed from year to year_built
                                color: "#000",
                                weight: 0.5,
                                opacity: 0.9,
                                fillOpacity: 0.7,
                            });
                        },
                        onEachFeature: function (feature, layer) {
                            layer.on({
                                mouseover: function (e) {
                                    info.update(feature.properties);
                                },
                                mouseout: function (e) {
                                    info.update();
                                },
                            });
                        },
                    }).addTo(map);

                    // If there are no buildings with age data, show a message
                    if (buildingsWithYear.length === 0) {
                        alert("No building age data available for this city");
                        // Fall back to distance visualization
                        document.getElementById("show-age").checked = false;
                        toggleMode("distance");
                    }
                } else {
                    // Use all data without sampling for performance
                    const allBuildingsGeoJson = {
                        type: "FeatureCollection",
                        features: geoJsonData.features,
                    };

                    // Create distance or modes dots
                    buildingsLayer = L.geoJSON(allBuildingsGeoJson, {
                        renderer: canvasRenderer,
                        pointToLayer: function (feature, latlng) {
                            const color =
                                mode === "distance"
                                    ? getDistanceColor(
                                          feature.properties.transit_distance
                                      ) // Changed from transport_distance to transit_distance
                                    : getModesColor(
                                          feature.properties.transit_modes
                                      );

                            return L.circleMarker(latlng, {
                                radius: radius,
                                fillColor: color,
                                color: "#000",
                                weight: 0.5,
                                opacity: 0.9,
                                fillOpacity: 0.7,
                            });
                        },
                        onEachFeature: function (feature, layer) {
                            layer.on({
                                mouseover: function (e) {
                                    info.update(feature.properties);
                                },
                                mouseout: function (e) {
                                    info.update();
                                },
                            });
                        },
                    }).addTo(map);
                }
            }

            // Create transit stops layer
            function createTransitStopsLayer() {
                if (
                    !transitPointsData ||
                    !transitPointsData.points ||
                    transitPointsData.points.length === 0
                )
                    return;

                if (stopsLayer) map.removeLayer(stopsLayer);

                const stopsGeoJson = {
                    type: "FeatureCollection",
                    features: transitPointsData.points.map((point) => ({
                        type: "Feature",
                        geometry: {
                            type: "Point",
                            coordinates: point.coords,
                        },
                        properties: {
                            type: point.type,
                        },
                    })),
                };

                // Create the stops layer
                stopsLayer = L.geoJSON(stopsGeoJson, {
                    pointToLayer: function (feature, latlng) {
                        // Different colors for different transit types
                        const color =
                            feature.properties.type === "subway"
                                ? "#D81B60"
                                : feature.properties.type === "bus"
                                ? "#1976D2"
                                : feature.properties.type === "tram"
                                ? "#388E3C"
                                : "#FFC107";

                        return L.circleMarker(latlng, {
                            radius: 6,
                            fillColor: color,
                            color: "white",
                            weight: 2,
                            opacity: 1,
                            fillOpacity: 0.9,
                        });
                    },
                    onEachFeature: function (feature, layer) {
                        layer.bindPopup(
                            `<b>${feature.properties.type.toUpperCase()} Stop</b>`
                        );
                    },
                }).addTo(map);

                toggleStops(); // Apply the current checkbox state
            }

            // Toggle transit stops visibility
            function toggleStops() {
                if (!stopsLayer) return;

                if (document.getElementById("show-stops").checked) {
                    map.addLayer(stopsLayer);
                } else {
                    map.removeLayer(stopsLayer);
                }
            }

            // Toggle building age visualization
            function toggleBuildingAge() {
                if (document.getElementById("show-age").checked) {
                    toggleMode("age");
                } else {
                    toggleMode("distance");
                }
            }

            // Setup map click handler
            function setupMapClickHandler() {
                map.off("click"); // Remove existing handlers

                map.on("click", function (e) {
                    if (!geoJsonData || !geoJsonData.features) return;

                    // Find the nearest building to the click location
                    let minDist = Infinity;
                    let nearestBuilding = null;

                    geoJsonData.features.forEach((feature) => {
                        const coords = feature.geometry.coordinates;
                        const latlng = L.latLng(coords[1], coords[0]);
                        const distance = e.latlng.distanceTo(latlng);

                        if (distance < minDist) {
                            minDist = distance;
                            nearestBuilding = feature;
                        }
                    });

                    // If within 100 meters of a building, show its info
                    if (minDist < 100 && nearestBuilding) {
                        info.update(nearestBuilding.properties);
                    }
                });
            }

            // Display city metrics
            function displayCityMetrics() {
                const cityMetricsElement =
                    document.getElementById("city-metrics");

                if (
                    !geoJsonData ||
                    !geoJsonData.features ||
                    geoJsonData.features.length === 0
                ) {
                    cityMetricsElement.innerHTML =
                        "<p class='text-center text-gray-400'>No city metrics data available</p>";
                    return;
                }

                // Prepare transit points distribution
                let transitDistribution = "";
                if (transitPointsData && transitPointsData.typeCounts) {
                    transitDistribution = Object.entries(
                        transitPointsData.typeCounts
                    )
                        .map(
                            ([type, count]) => `
                            <div>${
                                type.charAt(0).toUpperCase() + type.slice(1)
                            }:</div>
                            <div class="text-right font-medium">${count}</div>
                        `
                        )
                        .join("");
                }

                // If we have city metrics from the JSON file, use those values
                if (cityMetricsData) {
                    // Create the metrics HTML using the city-level metrics JSON
                    cityMetricsElement.innerHTML = `
                        <div class="grid grid-cols-2 gap-2 text-sm">
                            <div>Total buildings:</div>
                            <div class="text-right font-medium">${cityMetricsData.total_buildings.toLocaleString()}</div>
                            <div>Total transit points:</div>
                            <div class="text-right font-medium">${
                                transitPointsData
                                    ? transitPointsData.totalCount
                                    : "N/A"
                            }</div>
                        </div>
                        
                        <div class="mt-3 pt-3 border-t border-gray-200">
                            <h3 class="font-bold text-gray-700 mb-2">Transit Points Distribution</h3>
                            <div class="grid grid-cols-2 gap-2 text-sm">
                                ${transitDistribution}
                            </div>
                        </div>
                        
                        <div class="mt-3 pt-3 border-t border-gray-200">
                            <h3 class="font-bold text-gray-700 mb-2">Urban Form</h3>
                            <div class="grid grid-cols-2 gap-2 text-sm">
                                <div>Average distance to transit:</div>
                                <div class="text-right font-medium">${Math.round(
                                    cityMetricsData.avg_transport_distance
                                )} meters</div>
                                
                                ${
                                    cityMetricsData.green_space_ratio !==
                                    undefined
                                        ? `
                                <div>Green cover percentage:</div>
                                <div class="text-right font-medium">${(
                                    cityMetricsData.green_space_ratio * 100 || 0
                                ).toFixed(1)}%</div>`
                                        : ""
                                }
                                
                                ${
                                    cityMetricsData.building_to_street_ratio !==
                                    undefined
                                        ? `
                                <div>Building-to-street ratio:</div>
                                <div class="text-right font-medium">${cityMetricsData.building_to_street_ratio.toFixed(
                                    2
                                )}</div>`
                                        : ""
                                }
                            </div>
                        </div>
                    `;
                } else {
                    // Fallback to calculating metrics from GeoJSON if city metrics file not available
                    const totalBuildings = geoJsonData.features.length;

                    // Calculate transport metrics
                    const avgDistance =
                        geoJsonData.features.reduce(
                            (sum, b) => sum + b.properties.transport_distance,
                            0
                        ) / totalBuildings;
                    const buildingsNearTransit = geoJsonData.features.filter(
                        (b) => b.properties.transport_modes > 0
                    ).length;
                    const transitAccessPercent = Math.round(
                        (buildingsNearTransit / totalBuildings) * 100
                    );

                    // Calculate green space metrics if available
                    let greenSpaceStats = "";
                    let greenCoverPct = "N/A";
                    if (geoJsonData.features[0].properties.green_distance) {
                        const buildingsNearGreen = geoJsonData.features.filter(
                            (b) => b.properties.nearby_green_area > 0
                        ).length;
                        const greenAccessPercent = Math.round(
                            (buildingsNearGreen / totalBuildings) * 100
                        );

                        // Estimate green cover from nearby_green_area if available
                        if (
                            geoJsonData.features[0].properties
                                .nearby_green_area !== undefined
                        ) {
                            const totalArea = geoJsonData.features.reduce(
                                (sum, b) =>
                                    sum + (b.properties.nearby_green_area || 0),
                                0
                            );
                            greenCoverPct = (
                                (totalArea / (totalBuildings * 10000)) *
                                100
                            ).toFixed(1);
                        }

                        greenSpaceStats = `
                            <div class="mt-3 pt-3 border-t border-gray-200">
                                <h3 class="font-bold text-gray-700 mb-2">Green Space</h3>
                                <div class="grid grid-cols-2 gap-2 text-sm">
                                    <div>Green cover percentage:</div>
                                    <div class="text-right font-medium">${greenCoverPct}%</div>
                                    <div>Buildings near green space:</div>
                                    <div class="text-right font-medium">${greenAccessPercent}%</div>
                                </div>
                            </div>
                        `;
                    }

                    // Create the metrics HTML
                    cityMetricsElement.innerHTML = `
                        <div class="grid grid-cols-2 gap-2 text-sm">
                            <div>Total buildings:</div>
                            <div class="text-right font-medium">${totalBuildings.toLocaleString()}</div>
                            <div>Total transit points:</div>
                            <div class="text-right font-medium">${
                                transitPointsData
                                    ? transitPointsData.totalCount
                                    : "N/A"
                            }</div>
                        </div>
                        
                        <div class="mt-3 pt-3 border-t border-gray-200">
                            <h3 class="font-bold text-gray-700 mb-2">Transit Points Distribution</h3>
                            <div class="grid grid-cols-2 gap-2 text-sm">
                                ${transitDistribution}
                            </div>
                        </div>
                        
                        <div class="mt-3 pt-3 border-t border-gray-200">
                            <h3 class="font-bold text-gray-700 mb-2">Urban Form</h3>
                            <div class="grid grid-cols-2 gap-2 text-sm">
                                <div>Average distance to transit:</div>
                                <div class="text-right font-medium">${Math.round(
                                    avgDistance
                                )} meters</div>
                                <div>Green cover percentage:</div>
                                <div class="text-right font-medium">${greenCoverPct}%</div>
                                <div>Building-to-street ratio:</div>
                                <div class="text-right font-medium">N/A</div>
                            </div>
                        </div>
                    `;
                }

                // Create the charts
                createTransitChart();
                createModeChart();
                createAgeChart();
            }

            // Create transit accessibility chart
            function createTransitChart() {
                if (
                    !geoJsonData ||
                    !geoJsonData.features ||
                    geoJsonData.features.length === 0
                )
                    return;

                const canvas = document.getElementById("transit-chart");
                const ctx = canvas.getContext("2d");

                // Calculate distance buckets
                const distanceBuckets = {
                    "< 100m": 0,
                    "100-300m": 0,
                    "300-600m": 0,
                    "600-1000m": 0,
                    "> 1000m": 0,
                };

                // Debugging - log the first few distance values
                console.log(
                    "First 10 distance values:",
                    geoJsonData.features.slice(0, 10).map(
                        (f) => f.properties.transit_distance // Changed from transport_distance to transit_distance
                    )
                );

                // Make sure transit_distance is a number
                geoJsonData.features.forEach((feature) => {
                    // Changed from transport_distance to transit_distance
                    const distance = parseFloat(
                        feature.properties.transit_distance
                    );

                    // Skip invalid values
                    if (isNaN(distance)) return;

                    if (distance < 100) distanceBuckets["< 100m"]++;
                    else if (distance < 300) distanceBuckets["100-300m"]++;
                    else if (distance < 600) distanceBuckets["300-600m"]++;
                    else if (distance < 1000) distanceBuckets["600-1000m"]++;
                    else distanceBuckets["> 1000m"]++;
                });

                // Log the final counts for debugging
                console.log("Distance bucket counts:", distanceBuckets);

                // Create chart
                if (window.transitChart) window.transitChart.destroy();

                window.transitChart = new Chart(ctx, {
                    type: "bar",
                    data: {
                        labels: Object.keys(distanceBuckets),
                        datasets: [
                            {
                                label: "Buildings",
                                data: Object.values(distanceBuckets),
                                backgroundColor: [
                                    "#1a9850",
                                    "#a6d96a",
                                    "#fee08b",
                                    "#fdae61",
                                    "#d73027",
                                ],
                                borderWidth: 1,
                            },
                        ],
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            title: { display: false },
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: "Number of Buildings",
                                },
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: "Distance to Transit",
                                },
                            },
                        },
                    },
                });
            }

            // Create mode distribution chart
            function createModeChart() {
                if (
                    !geoJsonData ||
                    !geoJsonData.features ||
                    geoJsonData.features.length === 0
                )
                    return;

                const canvas = document.getElementById("mode-chart");
                const ctx = canvas.getContext("2d");

                // Calculate mode buckets
                const modeBuckets = {
                    "No transit": 0,
                    "1 mode": 0,
                    "2 modes": 0,
                    "3 modes": 0,
                    "4+ modes": 0,
                };

                geoJsonData.features.forEach((feature) => {
                    const modes = feature.properties.transport_modes;
                    if (modes === 0) modeBuckets["No transit"]++;
                    else if (modes === 1) modeBuckets["1 mode"]++;
                    else if (modes === 2) modeBuckets["2 modes"]++;
                    else if (modes === 3) modeBuckets["3 modes"]++;
                    else modeBuckets["4+ modes"]++;
                });

                // Create chart
                if (window.modeChart) window.modeChart.destroy();

                window.modeChart = new Chart(ctx, {
                    type: "pie",
                    data: {
                        labels: Object.keys(modeBuckets),
                        datasets: [
                            {
                                data: Object.values(modeBuckets),
                                backgroundColor: [
                                    "#deebf7",
                                    "#9ecae1",
                                    "#6baed6",
                                    "#3182bd",
                                    "#08519c",
                                ],
                                borderWidth: 1,
                            },
                        ],
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { position: "right" },
                        },
                    },
                });
            }

            // Create age distribution chart
            function createAgeChart() {
                const canvas = document.getElementById("age-chart");
                const ctx = canvas.getContext("2d");

                if (!ageDistributionData || ageDistributionData.length === 0) {
                    if (window.ageChart) window.ageChart.destroy();
                    return;
                }

                // Sort age periods chronologically
                const periodOrder = [
                    "Pre-1800",
                    "1800-1849",
                    "1850-1899",
                    "1900-1944",
                    "1945-1969",
                    "1970-1989",
                    "1990-1999",
                    "2000-2009",
                    "2010-present",
                    "Unknown",
                ];

                const sortedData = [...ageDistributionData].sort((a, b) => {
                    return (
                        periodOrder.indexOf(a.age_period) -
                        periodOrder.indexOf(b.age_period)
                    );
                });

                // Filter out "Unknown" for the chart
                const chartData = sortedData.filter(
                    (item) => item.age_period !== "Unknown"
                );

                // Create color gradient based on age
                const backgroundColors = chartData.map((item) => {
                    const period = item.age_period;
                    if (period === "Pre-1800") return "#67000d";
                    if (period === "1800-1849") return "#a50f15";
                    if (period === "1850-1899") return "#cb181d";
                    if (period === "1900-1944") return "#ef3b2c";
                    if (period === "1945-1969") return "#fb6a4a";
                    if (period === "1970-1989") return "#fc9272";
                    if (period === "1990-1999") return "#fcbba1";
                    if (period === "2000-2009") return "#fee0d2";
                    return "#fee5d9";
                });

                // Create chart
                if (window.ageChart) window.ageChart.destroy();

                window.ageChart = new Chart(ctx, {
                    type: "bar",
                    data: {
                        labels: chartData.map((item) => item.age_period),
                        datasets: [
                            {
                                label: "Buildings",
                                data: chartData.map((item) => item.count),
                                backgroundColor: backgroundColors,
                                borderWidth: 1,
                            },
                        ],
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        indexAxis: "y",
                        plugins: {
                            legend: { display: false },
                        },
                        scales: {
                            x: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: "Number of Buildings",
                                },
                            },
                        },
                    },
                });
            }

            // Set up event listeners
            function setupEventListeners() {
                document
                    .getElementById("distance-btn")
                    .addEventListener("click", () => {
                        document.getElementById("show-age").checked = false;
                        toggleMode("distance");
                    });

                document
                    .getElementById("modes-btn")
                    .addEventListener("click", () => {
                        document.getElementById("show-age").checked = false;
                        toggleMode("modes");
                    });

                document
                    .getElementById("show-stops")
                    .addEventListener("change", toggleStops);
                document
                    .getElementById("show-age")
                    .addEventListener("change", toggleBuildingAge);

                // Removed dot radius slider event listener
            }
        </script>
    </body>
</html>
