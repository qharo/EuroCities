<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Urban Accessibility Dashboard</title>

        <!-- External Libraries -->
        <script src="https://cdn.tailwindcss.com"></script>
        <link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css"
        />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.heat/0.2.0/leaflet-heat.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.js"></script>

        <!-- Add MarkerCluster plugin -->
        <link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.3/MarkerCluster.css"
        />
        <link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.3/MarkerCluster.Default.css"
        />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.3/leaflet.markercluster.js"></script>

        <style>
            .leaflet-container {
                height: 100%;
                width: 100%;
            }
            .info {
                padding: 6px 8px;
                font: 14px/16px Arial, Helvetica, sans-serif;
                background: rgba(255, 255, 255, 0.8);
                box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
                border-radius: 5px;
            }
            .legend {
                line-height: 18px;
                color: #555;
            }
            .legend i {
                width: 18px;
                height: 18px;
                float: left;
                margin-right: 8px;
                opacity: 0.7;
            }
            .search-results {
                max-height: 200px;
                overflow-y: auto;
            }
            /* Cluster Marker Styles */
            .cluster-marker {
                display: flex;
                align-items: center;
                justify-content: center;
                border-radius: 50%;
                color: white;
                font-weight: bold;
                box-shadow: 0 0 0 2px white;
            }
            .cluster-marker.small {
                width: 30px;
                height: 30px;
            }
            .cluster-marker.medium {
                width: 35px;
                height: 35px;
            }
            .cluster-marker.large {
                width: 40px;
                height: 40px;
            }
            .cluster-distance {
                background-color: rgba(26, 152, 80, 0.8);
            }
            .cluster-modes {
                background-color: rgba(8, 81, 156, 0.8);
            }
            .cluster-age {
                background-color: rgba(203, 24, 29, 0.8);
            }
            /* Toggle button styles */
            .toggle-btn {
                position: relative;
                display: inline-block;
                width: 48px;
                height: 24px;
            }
            .toggle-btn input {
                opacity: 0;
                width: 0;
                height: 0;
            }
            .toggle-slider {
                position: absolute;
                cursor: pointer;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: #ccc;
                border-radius: 24px;
                transition: 0.4s;
            }
            .toggle-slider:before {
                position: absolute;
                content: "";
                height: 18px;
                width: 18px;
                left: 3px;
                bottom: 3px;
                background-color: white;
                border-radius: 50%;
                transition: 0.4s;
            }
            input:checked + .toggle-slider {
                background-color: #3b82f6;
            }
            input:checked + .toggle-slider:before {
                transform: translateX(24px);
            }
        </style>
    </head>

    <body class="bg-gray-100">
        <div class="min-h-screen flex flex-col">
            <!-- Header -->
            <header class="bg-blue-600 text-white p-4 shadow-md">
                <div class="container mx-auto">
                    <h1 class="text-2xl font-bold">
                        Urban Accessibility Dashboard
                    </h1>
                </div>
            </header>

            <!-- Main Content -->
            <main class="flex-grow flex flex-col md:flex-row">
                <!-- Map Column -->
                <div class="w-full md:w-3/5 h-[70vh] md:h-screen relative">
                    <div
                        id="loading"
                        class="absolute inset-0 bg-white bg-opacity-90 z-50 flex items-center justify-center"
                    >
                        <div class="text-center p-4">
                            <div
                                class="spinner-border inline-block w-8 h-8 border-4 border-t-blue-500 border-r-transparent border-b-blue-500 border-l-transparent rounded-full animate-spin mb-4"
                            ></div>
                            <p class="text-gray-700">
                                Select a city to view the visualization
                            </p>
                        </div>
                    </div>

                    <div id="map" class="h-full"></div>
                </div>

                <!-- Metrics Column -->
                <div class="w-full md:w-2/5 p-4 overflow-auto h-screen">
                    <!-- Search Box -->
                    <div class="bg-white rounded-lg shadow-md p-4 mb-4">
                        <h4 class="font-bold text-gray-700 mb-2">
                            Search City
                        </h4>
                        <div class="relative">
                            <input
                                type="text"
                                id="city-search"
                                placeholder="Type to search..."
                                class="w-full p-2 border border-gray-300 rounded"
                            />
                            <div
                                id="search-results"
                                class="absolute left-0 right-0 mt-1 bg-white rounded shadow-lg hidden search-results z-50"
                            >
                                <!-- Search results will appear here -->
                            </div>
                        </div>
                        <div
                            id="selected-city"
                            class="mt-2 text-xs text-gray-500 text-center"
                        >
                            No city selected
                        </div>
                    </div>

                    <!-- Visualization Options -->
                    <div class="bg-white rounded-lg shadow-md p-4 mb-4">
                        <h4 class="font-bold text-gray-700 mb-2">
                            Data Visualization
                        </h4>
                        <div class="flex flex-col space-y-2">
                            <div class="grid grid-cols-2 gap-2">
                                <button
                                    id="distance-btn"
                                    class="px-3 py-1 text-sm rounded border border-gray-300 bg-blue-500 text-white hover:bg-blue-600 transition"
                                >
                                    Distance to Transit
                                </button>
                                <button
                                    id="modes-btn"
                                    class="px-3 py-1 text-sm rounded border border-gray-300 bg-white hover:bg-gray-100 transition"
                                >
                                    Transit Mode Variety
                                </button>
                            </div>

                            <div class="flex items-center mt-1">
                                <input
                                    type="checkbox"
                                    id="show-stops"
                                    class="mr-2"
                                    checked
                                />
                                <label for="show-stops" class="text-sm"
                                    >Show Transit Stops</label
                                >
                            </div>

                            <div class="flex items-center mt-1">
                                <input
                                    type="checkbox"
                                    id="show-age"
                                    class="mr-2"
                                />
                                <label for="show-age" class="text-sm"
                                    >Show Building Age</label
                                >
                            </div>
                        </div>

                        <input
                            type="hidden"
                            id="use-viewport-filtering"
                            checked
                        />
                    </div>

                    <div class="bg-white rounded-lg shadow-md p-4 mb-4">
                        <h2 class="text-xl font-bold text-gray-800 mb-3">
                            City Metrics
                        </h2>
                        <div id="city-metrics" class="text-gray-600">
                            <p class="text-center text-gray-400">
                                Select a city to see metrics
                            </p>
                        </div>
                        <div
                            id="points-count"
                            class="text-sm text-gray-500 mt-2 text-right"
                        ></div>
                    </div>

                    <div class="bg-white rounded-lg shadow-md p-4 mb-4">
                        <h2 class="text-xl font-bold text-gray-800 mb-3">
                            Transit Accessibility
                        </h2>
                        <div class="h-64">
                            <canvas id="transit-chart"></canvas>
                        </div>
                    </div>

                    <div class="bg-white rounded-lg shadow-md p-4 mb-4">
                        <h2 class="text-xl font-bold text-gray-800 mb-3">
                            Transport Mode Distribution
                        </h2>
                        <div class="h-64">
                            <canvas id="mode-chart"></canvas>
                        </div>
                    </div>

                    <div class="bg-white rounded-lg shadow-md p-4">
                        <h2 class="text-xl font-bold text-gray-800 mb-3">
                            Building Age Distribution
                        </h2>
                        <div class="h-64">
                            <canvas id="age-chart"></canvas>
                        </div>
                    </div>
                </div>
            </main>
        </div>

        <script>
            const cityData = [
                {
                    name: "Paris",
                    geojsonUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/ef2165a6d5654ae6ea9063f78af99a71583a1990/Cities/Paris/paris.geojson",
                    metricsUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/ef2165a6d5654ae6ea9063f78af99a71583a1990/Cities/Paris/paris_city_metrics.json",
                },
                {
                    name: "Lyon",
                    geojsonUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Lyon/lyon.geojson",
                    metricsUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Lyon/lyon_city_metrics.json",
                },
                {
                    name: "Marseille",
                    geojsonUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Marseille/marseille.geojson",
                    metricsUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Marseille/marseille_city_metrics.json",
                },
                {
                    name: "Toulouse",
                    geojsonUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Toulouse/toulouse.geojson",
                    metricsUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Toulouse/toulouse_city_metrics.json",
                },
                {
                    name: "Milan",
                    geojsonUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Milan/milan.geojson",
                    metricsUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Milan/milan_city_metrics.json",
                },
                {
                    name: "Madrid",
                    geojsonUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Madrid/madrid.geojson",
                    metricsUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Madrid/madrid_city_metrics.json",
                },
                {
                    name: "Zaragoza",
                    geojsonUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Zaragoza/zaragoza.geojson",
                    metricsUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Zaragoza/zaragoza_city_metrics.json",
                },
                {
                    name: "Valencia",
                    geojsonUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Valencia/valencia.geojson",
                    metricsUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Valencia/valencia_city_metrics.json",
                },
                {
                    name: "Lisbon",
                    geojsonUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Lisbon/lisbon.geojson",
                    metricsUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Lisbon/lisbon_city_metrics.json",
                },
                {
                    name: "Frankfurt",
                    geojsonUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Frankfurt/frankfurt.geojson",
                    metricsUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Frankfurt/frankfurt_city_metrics.json",
                },

                {
                    name: "Brussels",
                    geojsonUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Brussels/brussels.geojson",
                    metricsUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Brussels/brussels_city_metrics.json",
                },

                {
                    name: "Barcelona",
                    geojsonUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Barcelona/barcelona.geojson",
                    metricsUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Barcelona/barcelona_city_metrics.json",
                },
                {
                    name: "Amsterdam",
                    geojsonUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Amsterdam/amsterdam.geojson",
                    metricsUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Amsterdam/amsterdam_city_metrics.json",
                },
                {
                    name: "Sevilla",
                    geojsonUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Sevilla/seville.geojson",
                    metricsUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Sevilla/seville_city_metrics.json",
                },
                {
                    name: "Vienna",
                    geojsonUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Vienna/vienna.geojson",
                    metricsUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Vienna/vienna_city_metrics.json",
                },
                {
                    name: "Antwerp",
                    geojsonUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Antwerp/antwerp.geojson",
                    metricsUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Antwerp/antwerp_city_metrics.json",
                },
                {
                    name: "Munich",
                    geojsonUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Munich/munich.geojson",
                    metricsUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Munich/munich_city_metrics.json",
                },
                {
                    name: "Nice",
                    geojsonUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Nice/nice.geojson",
                    metricsUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Nice/nice_city_metrics.json",
                },
                {
                    name: "Rome",
                    geojsonUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Rome/rome.geojson",
                    metricsUrl:
                        "https://raw.githubusercontent.com/qharo/EuroCities/main/Cities/Rome/rome_city_metrics.json",
                },
            ];

            // Variables for our global data and layers
            let map, info, distanceLegend, modesLegend, ageLegend;
            let buildingsLayer,
                stopsLayer,
                buildingAgeLayer,
                clusterLayer,
                heatmapLayer,
                customCanvasLayer;
            let currentMode = "distance"; // Default view
            let geoJsonData; // Will store our GeoJSON data
            let ageDistributionData; // Will store building age distribution
            let cityMetricsData;
            let transitPointsData; // Will store transit points info

            // Performance optimization settings
            // Dot mode is the only view mode
            let useDataClustering = false; // No clustering
            let useSampling = false; // Use all points
            let samplingRate = 1.0; // Show 100% of the points
            let useViewportFiltering = true;
            let viewportFilterBufferFactor = 0.5; // Buffer around the viewport
            let useCustomCanvasRenderer = true; // Always use advanced renderer

            // Custom Canvas Overlay Class
            class CanvasOverlay extends L.Layer {
                constructor(options) {
                    super(options);
                    this._data = options.data || [];
                    this._colorFunction =
                        options.colorFunction || (() => "#ff0000");
                    this._radiusFunction = options.radiusFunction || (() => 3);
                    this._onClick = options.onClick || null;
                    this._onHover = options.onHover || null;
                    this._currentHover = null;
                    this._zoomAnimated = false;
                }

                onAdd(map) {
                    this._map = map;

                    // Create canvas element
                    const canvas = L.DomUtil.create(
                        "canvas",
                        "leaflet-canvas-layer"
                    );
                    const size = map.getSize();
                    canvas.width = size.x;
                    canvas.height = size.y;

                    this._canvas = canvas;
                    this._ctx = canvas.getContext("2d");

                    // Position the canvas
                    L.DomUtil.setPosition(
                        canvas,
                        map.containerPointToLayerPoint([0, 0])
                    );

                    // Append to the overlay pane
                    map.getPanes().overlayPane.appendChild(canvas);

                    // Add event listeners
                    map.on("moveend", this._reset, this);
                    map.on("resize", this._resize, this);

                    if (this._onClick || this._onHover) {
                        this._canvas.style.pointerEvents = "auto";
                        this._canvas.addEventListener(
                            "click",
                            this._handleClick.bind(this)
                        );
                        this._canvas.addEventListener(
                            "mousemove",
                            this._handleMouseMove.bind(this)
                        );
                        this._canvas.addEventListener(
                            "mouseout",
                            this._handleMouseOut.bind(this)
                        );
                    }

                    // Initial draw
                    this._reset();
                }

                onRemove(map) {
                    map.off("moveend", this._reset, this);
                    map.off("resize", this._resize, this);

                    if (this._canvas) {
                        // Remove event listeners
                        if (this._onClick || this._onHover) {
                            this._canvas.removeEventListener(
                                "click",
                                this._handleClick.bind(this)
                            );
                            this._canvas.removeEventListener(
                                "mousemove",
                                this._handleMouseMove.bind(this)
                            );
                            this._canvas.removeEventListener(
                                "mouseout",
                                this._handleMouseOut.bind(this)
                            );
                        }

                        // Remove from DOM
                        if (this._canvas.parentNode) {
                            this._canvas.parentNode.removeChild(this._canvas);
                        }
                    }

                    this._canvas = null;
                    this._ctx = null;
                    this._map = null;
                }

                setData(data) {
                    this._data = data;
                    this._reset();
                }

                _resize(event) {
                    if (!this._map || !this._canvas) return;

                    const size = this._map.getSize();
                    this._canvas.width = size.x;
                    this._canvas.height = size.y;
                    this._reset();
                }

                _reset() {
                    if (!this._map || !this._canvas) return;

                    const topLeft = this._map.containerPointToLayerPoint([
                        0, 0,
                    ]);
                    L.DomUtil.setPosition(this._canvas, topLeft);
                    this._redraw();
                }

                _redraw() {
                    if (!this._map || !this._canvas) return;

                    const ctx = this._ctx;
                    const canvas = this._canvas;
                    const map = this._map;

                    // Clear canvas
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // Draw all data points
                    if (!this._data || !Array.isArray(this._data)) return;
                    this._data.forEach((feature) => {
                        const coords = feature.geometry.coordinates;
                        const latlng = L.latLng(coords[1], coords[0]);
                        const point = map.latLngToContainerPoint(latlng);

                        // Only draw if the point is within the visible area (with a buffer)
                        if (
                            point.x > -50 &&
                            point.y > -50 &&
                            point.x < canvas.width + 50 &&
                            point.y < canvas.height + 50
                        ) {
                            const color = this._colorFunction(feature);
                            const radius = this._radiusFunction(feature);

                            ctx.beginPath();
                            ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
                            ctx.fillStyle = color;
                            ctx.fill();

                            ctx.strokeStyle = "#000";
                            ctx.lineWidth = 0.5;
                            ctx.stroke();

                            // Store point location for hit detection
                            feature._canvasPoint = point;
                            feature._canvasRadius = radius;
                        } else {
                            feature._canvasPoint = null; // Not visible
                        }
                    });
                }

                _handleClick(e) {
                    if (!this._onClick || !this._canvas) return;

                    const rect = this._canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    const feature = this._findFeatureAt(x, y);
                    if (feature) {
                        this._onClick(feature);
                    }
                }

                _handleMouseMove(e) {
                    if (!this._onHover || !this._canvas) return;

                    const rect = this._canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    const feature = this._findFeatureAt(x, y);

                    if (feature !== this._currentHover) {
                        if (this._currentHover) {
                            this._onHover(null); // Mouse out
                        }

                        this._currentHover = feature;

                        if (feature) {
                            this._onHover(feature); // Mouse over
                        }
                    }

                    // Change cursor based on hit
                    this._canvas.style.cursor = feature ? "pointer" : "auto";
                }

                _handleMouseOut() {
                    if (this._currentHover && this._onHover) {
                        this._onHover(null);
                        this._currentHover = null;
                    }
                }

                _findFeatureAt(x, y) {
                    // Find the feature under the mouse cursor
                    if (!this._data || !Array.isArray(this._data)) return null;

                    for (let i = this._data.length - 1; i >= 0; i--) {
                        const feature = this._data[i];
                        if (!feature) continue;

                        const point = feature._canvasPoint;
                        if (!point) continue; // Point not visible

                        const dx = point.x - x;
                        const dy = point.y - y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance <= feature._canvasRadius + 2) {
                            // Slightly larger hit area
                            return feature;
                        }
                    }

                    return null;
                }
            }

            // Init map
            initMap();
            setupSearchAutocomplete();
            setupEventListeners();

            // Initialize the map
            function initMap() {
                map = L.map("map").setView([46.603354, 1.888334], 6); // Center on France

                L.tileLayer(
                    "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
                    {
                        maxZoom: 19,
                        attribution:
                            '&copy; <a href="https://openstreetmap.org/copyright">OpenStreetMap contributors</a>',
                    }
                ).addTo(map);

                // Initialize info control
                info = createInfoControl();
                info.addTo(map);

                // Initialize legends
                distanceLegend = createLegend("distance");
                modesLegend = createLegend("modes");
                ageLegend = createLegend("age");

                // Setup map events for various renderers
                setupMapMoveEvents();
                setupMapEventsForCustomCanvas();
            }

            // Initialize the search autocomplete
            function setupSearchAutocomplete() {
                const searchInput = document.getElementById("city-search");
                const searchResults = document.getElementById("search-results");

                searchInput.addEventListener("input", function () {
                    const query = this.value.toLowerCase();
                    if (query.length < 2) {
                        searchResults.classList.add("hidden");
                        return;
                    }

                    const filteredCities = cityData.filter((city) =>
                        city.name.toLowerCase().includes(query)
                    );

                    if (filteredCities.length > 0) {
                        searchResults.innerHTML = "";
                        filteredCities.forEach((city) => {
                            const div = document.createElement("div");
                            div.className =
                                "p-2 hover:bg-gray-100 cursor-pointer";
                            div.textContent = city.name;
                            div.addEventListener("click", () => {
                                loadCity(city);
                                searchInput.value = city.name;
                                searchResults.classList.add("hidden");
                            });
                            searchResults.appendChild(div);
                        });
                        searchResults.classList.remove("hidden");
                    } else {
                        searchResults.classList.add("hidden");
                    }
                });

                // Close results when clicking outside
                document.addEventListener("click", function (e) {
                    if (
                        e.target !== searchInput &&
                        !searchResults.contains(e.target)
                    ) {
                        searchResults.classList.add("hidden");
                    }
                });
            }

            function sanitizeJSONString(jsonString) {
                // Replace NaN and Infinity values with null in JSON string
                return jsonString
                    .replace(/: *NaN/g, ": null")
                    .replace(/: *Infinity/g, ": null")
                    .replace(/: *-Infinity/g, ": null");
            }

            function loadCity(city) {
                document.getElementById(
                    "selected-city"
                ).textContent = `Selected: ${city.name}`;
                document.getElementById("loading").style.display = "flex";
                document.getElementById("loading").innerHTML = `
                    <div class="text-center p-4">
                        <div class="spinner-border inline-block w-8 h-8 border-4 border-t-blue-500 border-r-transparent border-b-blue-500 border-l-transparent rounded-full animate-spin mb-4"></div>
                        <p class="text-gray-700">Loading data for ${city.name}...</p>
                    </div>
                `;

                // Load GeoJSON data
                fetch(city.geojsonUrl)
                    .then((response) => {
                        if (!response.ok)
                            throw new Error(
                                `Error loading GeoJSON data for ${city.name}`
                            );
                        return response.text(); // Get as text first
                    })
                    .then((text) => {
                        // Sanitize JSON string by replacing NaN with null
                        const sanitizedText = sanitizeJSONString(text);
                        return JSON.parse(sanitizedText);
                    })
                    .then((data) => {
                        // Transform coordinates if needed
                        geoJsonData = transformGeoJSON(data);

                        // Load city metrics data
                        return fetch(city.metricsUrl)
                            .then((response) => {
                                if (!response.ok)
                                    throw new Error(
                                        `Error loading metrics for ${city.name}`
                                    );
                                return response.text(); // Get as text first
                            })
                            .then((text) => {
                                // Sanitize JSON string by replacing NaN with null
                                const sanitizedText = sanitizeJSONString(text);
                                return JSON.parse(sanitizedText);
                            })
                            .then((cityMetrics) => {
                                // Extract age distribution data from city metrics
                                ageDistributionData =
                                    cityMetrics.building_age_distribution || [];
                                cityMetricsData = cityMetrics;
                                return { geoJsonData, cityMetricsData };
                            })
                            .catch((error) => {
                                console.warn(
                                    "Could not load city metrics data:",
                                    error
                                );
                                ageDistributionData = [];
                                cityMetricsData = null;
                                return { geoJsonData, cityMetricsData: null };
                            });
                    })
                    .then((data) => {
                        document.getElementById("loading").style.display =
                            "none";

                        // Generate transit stops data
                        generateTransitPointsData(geoJsonData);

                        // Render visualizations
                        clearLayers();
                        toggleMode(currentMode);
                        createTransitStopsLayer();
                        displayCityMetrics();

                        // Fit map to data bounds
                        fitMapToBounds();

                        // Set up click handlers
                        setupMapClickHandler();

                        // Update points count
                        updatePointsCount();
                    })
                    .catch((error) => {
                        console.error("Error loading city data:", error);
                        document.getElementById("loading").innerHTML = `
                            <div class="text-center p-4">
                                <p class="text-red-600">Error loading data: ${error.message}</p>
                            </div>
                        `;
                    });
            }

            // Update points count in the UI
            function updatePointsCount() {
                if (!geoJsonData || !geoJsonData.features) return;

                const pointsCountElement =
                    document.getElementById("points-count");

                // If the element doesn't exist, don't try to update it
                if (!pointsCountElement) return;

                const totalPoints = geoJsonData.features.length;
                pointsCountElement.textContent = `Total data points: ${totalPoints.toLocaleString()}`;
            }

            // Transform coordinates from Lambert-93 to WGS84 if needed
            function transformGeoJSON(geojson) {
                // Define coordinate transformation from EPSG:2154 (Lambert 93) to WGS84
                proj4.defs(
                    "EPSG:2154",
                    "+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
                );
                proj4.defs("EPSG:4326", "+proj=longlat +datum=WGS84 +no_defs");

                // Create a deep clone of the GeoJSON
                const transformed = JSON.parse(JSON.stringify(geojson));

                // Check if coordinates need transformation (detect Lambert-93)
                const needsTransform = transformed.features.some((feature) => {
                    const coords = feature.geometry.coordinates;
                    return (
                        Array.isArray(coords) &&
                        coords.length === 2 &&
                        (coords[0] > 600000 || coords[1] > 6000000)
                    );
                });

                if (needsTransform) {
                    transformed.features.forEach((feature) => {
                        try {
                            const coords = feature.geometry.coordinates;
                            const transformedCoords = proj4(
                                "EPSG:2154",
                                "EPSG:4326",
                                coords
                            );
                            feature.geometry.coordinates = transformedCoords;
                        } catch (error) {
                            console.error("Transformation error:", error);
                        }
                    });
                }

                return transformed;
            }

            // Generate transit points data
            function generateTransitPointsData(data) {
                if (!data || !data.features || data.features.length === 0)
                    return;

                // Find buildings with shortest distances (likely closest to actual stops)
                const buildings = [...data.features];
                buildings.sort(
                    (a, b) =>
                        a.properties.transport_distance -
                        b.properties.transport_distance
                );

                // Use the closest ~5% of buildings as proxies for stops
                const stopCount = Math.max(
                    5,
                    Math.ceil(buildings.length * 0.05)
                );
                const transitPoints = [];
                const usedPositions = new Set();

                for (
                    let i = 0;
                    i < Math.min(stopCount, buildings.length);
                    i++
                ) {
                    const building = buildings[i];
                    const coords = building.geometry.coordinates;

                    // Create a simple hash of the position to avoid duplicates
                    const posKey = `${Math.round(
                        coords[0] * 1000
                    )},${Math.round(coords[1] * 1000)}`;

                    if (!usedPositions.has(posKey)) {
                        usedPositions.add(posKey);

                        // Assign transit type based on position
                        let type = "bus";
                        if (i % 4 === 0) type = "subway";
                        else if (i % 4 === 1) type = "bus";
                        else if (i % 4 === 2) type = "tram";
                        else type = "train";

                        transitPoints.push({
                            coords: coords,
                            type: type,
                        });
                    }
                }

                // Count by type
                const typeCounts = transitPoints.reduce((acc, point) => {
                    acc[point.type] = (acc[point.type] || 0) + 1;
                    return acc;
                }, {});

                transitPointsData = {
                    points: transitPoints,
                    totalCount: transitPoints.length,
                    typeCounts: typeCounts,
                };
            }

            // Clear existing layers
            function clearLayers() {
                if (buildingsLayer) map.removeLayer(buildingsLayer);
                if (buildingAgeLayer) map.removeLayer(buildingAgeLayer);
                if (stopsLayer) map.removeLayer(stopsLayer);
                if (heatmapLayer) map.removeLayer(heatmapLayer);
                if (clusterLayer) map.removeLayer(clusterLayer);
                if (customCanvasLayer) map.removeLayer(customCanvasLayer);
                map.removeControl(distanceLegend);
                map.removeControl(modesLegend);
                map.removeControl(ageLegend);
            }

            // Fit map to data bounds
            function fitMapToBounds() {
                if (
                    !geoJsonData ||
                    !geoJsonData.features ||
                    geoJsonData.features.length === 0
                )
                    return;

                const bounds = geoJsonData.features.reduce(
                    (bounds, feature) => {
                        const coords = feature.geometry.coordinates;
                        bounds.extend([coords[1], coords[0]]);
                        return bounds;
                    },
                    L.latLngBounds([])
                );

                if (bounds.isValid()) {
                    map.fitBounds(bounds);
                }
            }

            // Create info control for hovering
            function createInfoControl() {
                const info = L.control();

                info.onAdd = function () {
                    this._div = L.DomUtil.create("div", "info");
                    this.update();
                    return this._div;
                };

                info.update = function (props) {
                    this._div.innerHTML =
                        "<h4 class='font-bold mb-1'>Location Information</h4>" +
                        (props
                            ? `<b>Distance to transit:</b> ${Math.round(
                                  props.transit_distance
                              )} meters<br />` +
                              `<b>Transit modes within 100m:</b> ${props.transit_modes}<br />` +
                              (props.year_built && !isNaN(props.year_built)
                                  ? `<b>Built:</b> ${props.year_built} (${
                                        new Date().getFullYear() -
                                        props.year_built
                                    } years old)<br />`
                                  : "") +
                              (props.green_distance
                                  ? `<b>Distance to green space:</b> ${Math.round(
                                        props.green_distance
                                    )} meters<br />`
                                  : "")
                            : "Hover over the map");
                };

                return info;
            }

            // Create legend based on visualization mode
            function createLegend(type) {
                const legend = L.control({ position: "bottomright" });

                legend.onAdd = function () {
                    const div = L.DomUtil.create("div", "info legend");

                    if (type === "distance") {
                        const grades = [0, 100, 200, 400, 600, 800, 1000];
                        div.innerHTML =
                            "<h4 class='font-bold mb-2'>Distance to Transit (m)</h4>";

                        for (let i = 0; i < grades.length; i++) {
                            div.innerHTML +=
                                '<i style="background:' +
                                getDistanceColor(grades[i] + 1) +
                                '"></i> ' +
                                grades[i] +
                                (grades[i + 1]
                                    ? "&ndash;" + grades[i + 1] + " m<br>"
                                    : "+ m");
                        }
                    } else if (type === "modes") {
                        const grades = [0, 1, 2, 3, 4];
                        div.innerHTML =
                            "<h4 class='font-bold mb-2'>Transit Mode Variety</h4>";

                        for (let i = 0; i < grades.length; i++) {
                            div.innerHTML +=
                                '<i style="background:' +
                                getModesColor(grades[i]) +
                                '"></i> ' +
                                (grades[i] === 0
                                    ? "None"
                                    : grades[i] +
                                      (grades[i + 1]
                                          ? "&ndash;" + grades[i + 1] + "<br>"
                                          : "+"));
                        }
                    } else if (type === "age") {
                        const grades = [0, 10, 25, 50, 75, 100, 150, 200];
                        div.innerHTML =
                            "<h4 class='font-bold mb-2'>Building Age (years)</h4>";

                        for (let i = 0; i < grades.length; i++) {
                            const currentYear = new Date().getFullYear();
                            div.innerHTML +=
                                '<i style="background:' +
                                getAgeColor(currentYear - grades[i] - 1) +
                                '"></i> ' +
                                grades[i] +
                                (grades[i + 1]
                                    ? "&ndash;" + grades[i + 1] + "<br>"
                                    : "+");
                        }
                    }

                    return div;
                };

                return legend;
            }

            // Color scales for different metrics
            function getDistanceColor(d) {
                return d > 1000
                    ? "#d73027"
                    : d > 800
                    ? "#f46d43"
                    : d > 600
                    ? "#fdae61"
                    : d > 400
                    ? "#fee08b"
                    : d > 200
                    ? "#d9ef8b"
                    : d > 100
                    ? "#a6d96a"
                    : "#1a9850";
            }

            function getModesColor(d) {
                return d >= 4
                    ? "#08519c"
                    : d >= 3
                    ? "#3182bd"
                    : d >= 2
                    ? "#6baed6"
                    : d >= 1
                    ? "#9ecae1"
                    : "#deebf7";
            }

            function getAgeColor(year) {
                if (!year || isNaN(year)) return "#cccccc"; // No data

                const currentYear = new Date().getFullYear();
                const age = currentYear - year;

                return age > 200
                    ? "#67000d"
                    : age > 150
                    ? "#a50f15"
                    : age > 100
                    ? "#cb181d"
                    : age > 75
                    ? "#ef3b2c"
                    : age > 50
                    ? "#fb6a4a"
                    : age > 25
                    ? "#fc9272"
                    : age > 10
                    ? "#fcbba1"
                    : "#fee5d9";
            }

            // Toggle between visualization modes
            function toggleMode(mode) {
                currentMode = mode;

                // Remove existing layers and legends
                clearLayers();

                // Update button states
                document.getElementById("distance-btn").className =
                    "px-3 py-1 text-sm rounded border border-gray-300 bg-white hover:bg-gray-100 transition";
                document.getElementById("modes-btn").className =
                    "px-3 py-1 text-sm rounded border border-gray-300 bg-white hover:bg-gray-100 transition";

                // Add appropriate visualization based on settings
                if (useCustomCanvasRenderer) {
                    // Use custom canvas renderer for maximum performance
                    customCanvasLayer = createCustomCanvasLayer(mode);
                    if (customCanvasLayer) {
                        customCanvasLayer.addTo(map);
                    } else if (mode === "age") {
                        // Fall back to distance if no age data
                        toggleMode("distance");
                        return;
                    }
                } else {
                    // Use standard Leaflet visualization (dots or clustering)
                    renderBuildingDots(mode);
                }

                // Add the appropriate legend
                if (mode === "distance") {
                    document.getElementById("distance-btn").className =
                        "px-3 py-1 text-sm rounded border border-gray-300 bg-blue-500 text-white hover:bg-blue-600 transition";
                    distanceLegend.addTo(map);
                } else if (mode === "modes") {
                    document.getElementById("modes-btn").className =
                        "px-3 py-1 text-sm rounded border border-gray-300 bg-blue-500 text-white hover:bg-blue-600 transition";
                    modesLegend.addTo(map);
                } else if (mode === "age") {
                    ageLegend.addTo(map);
                }

                // Update transit stops visibility
                toggleStops();
            }

            // Sample and filter data based on user settings
            function sampleAndFilterData(features) {
                if (!features || features.length === 0) return [];

                // Start with all features
                let filteredFeatures = [...features];

                // Apply viewport filtering if enabled
                if (useViewportFiltering) {
                    const bounds = map.getBounds();

                    // Calculate buffer (in degrees, which is approximate)
                    const latBuffer =
                        (bounds.getNorth() - bounds.getSouth()) *
                        viewportFilterBufferFactor;
                    const lngBuffer =
                        (bounds.getEast() - bounds.getWest()) *
                        viewportFilterBufferFactor;

                    // Create extended bounds with buffer
                    const extendedBounds = L.latLngBounds(
                        L.latLng(
                            bounds.getSouth() - latBuffer,
                            bounds.getWest() - lngBuffer
                        ),
                        L.latLng(
                            bounds.getNorth() + latBuffer,
                            bounds.getEast() + lngBuffer
                        )
                    );

                    // Filter features within extended bounds
                    filteredFeatures = filteredFeatures.filter((feature) => {
                        const coords = feature.geometry.coordinates;
                        const latlng = L.latLng(coords[1], coords[0]);
                        return extendedBounds.contains(latlng);
                    });
                }

                // Apply sampling if enabled and if there are still many points
                if (useSampling && filteredFeatures.length > 2000) {
                    // Calculate how many points to keep
                    const targetCount = Math.max(
                        2000,
                        Math.floor(filteredFeatures.length * samplingRate)
                    );

                    if (filteredFeatures.length > targetCount) {
                        // Ensure deterministic sampling by using building IDs or coordinates
                        filteredFeatures.sort((a, b) => {
                            const coordsA = a.geometry.coordinates;
                            const coordsB = b.geometry.coordinates;
                            return (
                                coordsA[0] +
                                coordsA[1] -
                                (coordsB[0] + coordsB[1])
                            );
                        });

                        // Sample every nth element
                        const step = Math.floor(
                            filteredFeatures.length / targetCount
                        );
                        filteredFeatures = filteredFeatures.filter(
                            (_, index) => index % step === 0
                        );
                    }
                }

                return filteredFeatures;
            }

            // Render buildings as colored dots (with clustering option)
            function renderBuildingDots(mode) {
                if (
                    !geoJsonData ||
                    !geoJsonData.features ||
                    geoJsonData.features.length === 0
                )
                    return;

                if (buildingsLayer) map.removeLayer(buildingsLayer);
                if (buildingAgeLayer) map.removeLayer(buildingAgeLayer);
                if (clusterLayer) map.removeLayer(clusterLayer);

                const radius = 4; // Fixed dot radius

                // If we should use clustering and we have a lot of points
                if (useDataClustering && geoJsonData.features.length > 1000) {
                    // Create a cluster group
                    clusterLayer = L.markerClusterGroup({
                        maxClusterRadius: 40,
                        disableClusteringAtZoom: 17, // Show individual points at high zoom levels
                        spiderfyOnMaxZoom: false,
                        showCoverageOnHover: false,
                        iconCreateFunction: function (cluster) {
                            const count = cluster.getChildCount();
                            let size;
                            if (count < 10) size = "small";
                            else if (count < 100) size = "medium";
                            else size = "large";

                            let colorClass;
                            if (mode === "distance")
                                colorClass = "cluster-distance";
                            else if (mode === "modes")
                                colorClass = "cluster-modes";
                            else colorClass = "cluster-age";

                            return L.divIcon({
                                html: `<div class="cluster-marker ${colorClass} ${size}">${count}</div>`,
                                className: "",
                                iconSize: L.point(40, 40),
                            });
                        },
                    });

                    // Filter features based on mode
                    let features;
                    if (mode === "age") {
                        features = geoJsonData.features.filter(
                            (feature) =>
                                feature.properties.year_built &&
                                !isNaN(feature.properties.year_built)
                        );

                        if (features.length === 0) {
                            alert(
                                "No building age data available for this city"
                            );
                            // Fall back to distance visualization
                            document.getElementById("show-age").checked = false;
                            toggleMode("distance");
                            return;
                        }
                    } else {
                        features = geoJsonData.features;
                    }

                    // Sample data if needed
                    features = sampleAndFilterData(features);

                    // Create markers for each data point
                    features.forEach((feature) => {
                        const coords = feature.geometry.coordinates;
                        const latlng = L.latLng(coords[1], coords[0]);

                        let color;
                        if (mode === "distance") {
                            color = getDistanceColor(
                                feature.properties.transit_distance
                            );
                        } else if (mode === "modes") {
                            color = getModesColor(
                                feature.properties.transit_modes
                            );
                        } else if (mode === "age") {
                            color = getAgeColor(feature.properties.year_built);
                        } else {
                            color = "#cccccc"; // Default for unknown age
                        }

                        const marker = L.circleMarker(latlng, {
                            radius: radius,
                            fillColor: color,
                            color: "#000",
                            weight: 0.5,
                            opacity: 0.9,
                            fillOpacity: 0.7,
                        });

                        // Add popup on click instead of hover for better mobile experience
                        marker.bindPopup(() => {
                            let html = `<b>Distance to transit:</b> ${Math.round(
                                feature.properties.transit_distance
                            )} meters<br />`;
                            html += `<b>Transit modes within 100m:</b> ${feature.properties.transit_modes}<br />`;

                            if (
                                feature.properties.year_built &&
                                !isNaN(feature.properties.year_built)
                            ) {
                                html += `<b>Built:</b> ${
                                    feature.properties.year_built
                                } (${
                                    new Date().getFullYear() -
                                    feature.properties.year_built
                                } years old)<br />`;
                            }

                            if (feature.properties.green_distance) {
                                html += `<b>Distance to green space:</b> ${Math.round(
                                    feature.properties.green_distance
                                )} meters<br />`;
                            }

                            return html;
                        });

                        // Add hover events
                        marker.on({
                            mouseover: function () {
                                info.update(feature.properties);
                            },
                            mouseout: function () {
                                info.update();
                            },
                        });

                        clusterLayer.addLayer(marker);
                    });

                    map.addLayer(clusterLayer);

                    // Update points count
                    const pointsCountElement =
                        document.getElementById("points-count");
                    pointsCountElement.textContent = `Showing ${features.length.toLocaleString()} of ${geoJsonData.features.length.toLocaleString()} points (clustered)`;
                } else {
                    // Use canvas renderer for non-clustered points
                    const canvasRenderer = L.canvas({ padding: 0.5 });

                    if (mode === "age") {
                        // Filter buildings with year data
                        const buildingsWithYear = geoJsonData.features.filter(
                            (feature) =>
                                feature.properties.year_built &&
                                !isNaN(feature.properties.year_built)
                        );

                        if (buildingsWithYear.length === 0) {
                            alert(
                                "No building age data available for this city"
                            );
                            // Fall back to distance visualization
                            document.getElementById("show-age").checked = false;
                            toggleMode("distance");
                            return;
                        }

                        // Apply sampling and filtering
                        const filteredFeatures =
                            sampleAndFilterData(buildingsWithYear);

                        // Create a simplified GeoJSON with just the buildings that have year data
                        const ageGeoJson = {
                            type: "FeatureCollection",
                            features: filteredFeatures,
                        };

                        // Create building age dots
                        buildingAgeLayer = L.geoJSON(ageGeoJson, {
                            renderer: canvasRenderer,
                            pointToLayer: function (feature, latlng) {
                                return L.circleMarker(latlng, {
                                    radius: radius,
                                    fillColor: getAgeColor(
                                        feature.properties.year_built
                                    ),
                                    color: "#000",
                                    weight: 0.5,
                                    opacity: 0.9,
                                    fillOpacity: 0.7,
                                });
                            },
                            onEachFeature: function (feature, layer) {
                                layer.on({
                                    mouseover: function (e) {
                                        info.update(feature.properties);
                                    },
                                    mouseout: function (e) {
                                        info.update();
                                    },
                                });
                            },
                        }).addTo(map);

                        // Update points count
                        const pointsCountElement =
                            document.getElementById("points-count");
                        pointsCountElement.textContent = `Showing ${filteredFeatures.length.toLocaleString()} of ${buildingsWithYear.length.toLocaleString()} points with age data`;
                    } else {
                        // Apply sampling and filtering to all data
                        const filteredFeatures = sampleAndFilterData(
                            geoJsonData.features
                        );

                        // Create a simplified GeoJSON with the filtered buildings
                        const filteredGeoJson = {
                            type: "FeatureCollection",
                            features: filteredFeatures,
                        };

                        // Create distance or modes dots
                        buildingsLayer = L.geoJSON(filteredGeoJson, {
                            renderer: canvasRenderer,
                            pointToLayer: function (feature, latlng) {
                                const color =
                                    mode === "distance"
                                        ? getDistanceColor(
                                              feature.properties
                                                  .transit_distance
                                          )
                                        : getModesColor(
                                              feature.properties.transit_modes
                                          );

                                return L.circleMarker(latlng, {
                                    radius: radius,
                                    fillColor: color,
                                    color: "#000",
                                    weight: 0.5,
                                    opacity: 0.9,
                                    fillOpacity: 0.7,
                                });
                            },
                            onEachFeature: function (feature, layer) {
                                layer.on({
                                    mouseover: function (e) {
                                        info.update(feature.properties);
                                    },
                                    mouseout: function (e) {
                                        info.update();
                                    },
                                });
                            },
                        }).addTo(map);

                        // Update points count
                        const pointsCountElement =
                            document.getElementById("points-count");
                        pointsCountElement.textContent = `Showing ${filteredFeatures.length.toLocaleString()} of ${geoJsonData.features.length.toLocaleString()} points`;
                    }
                }
            }

            // Create a heat map layer
            function createHeatmapLayer() {
                if (
                    !geoJsonData ||
                    !geoJsonData.features ||
                    geoJsonData.features.length === 0
                )
                    return;

                // Create array of points with intensity based on the current visualization mode
                const heatPoints = [];

                geoJsonData.features.forEach((feature) => {
                    const coords = feature.geometry.coordinates;
                    let intensity;

                    if (currentMode === "distance") {
                        // Normalize intensity - closer to transit = higher intensity
                        const dist = feature.properties.transit_distance;
                        // Invert the intensity scale to match the dot colors
                        // 0-100m = high intensity (1.0), >1000m = low intensity (0.1)
                        if (dist < 100) intensity = 1.0;
                        else if (dist < 200) intensity = 0.85;
                        else if (dist < 400) intensity = 0.7;
                        else if (dist < 600) intensity = 0.5;
                        else if (dist < 800) intensity = 0.3;
                        else if (dist < 1000) intensity = 0.2;
                        else intensity = 0.1;
                    } else if (currentMode === "modes") {
                        // More transit modes = higher intensity
                        const modes = feature.properties.transit_modes;
                        // 4+ modes = high intensity (1.0), 0 modes = low intensity (0.1)
                        if (modes >= 4) intensity = 1.0;
                        else if (modes === 3) intensity = 0.7;
                        else if (modes === 2) intensity = 0.5;
                        else if (modes === 1) intensity = 0.3;
                        else intensity = 0.1;
                    } else if (currentMode === "age") {
                        // Older buildings = higher intensity (if year data exists)
                        const year = feature.properties.year_built;
                        if (year && !isNaN(year)) {
                            const currentYear = new Date().getFullYear();
                            const age = currentYear - year;
                            // Age scale: 200+ years = high intensity (1.0), <10 years = low intensity (0.1)
                            if (age > 200) intensity = 1.0;
                            else if (age > 150) intensity = 0.85;
                            else if (age > 100) intensity = 0.7;
                            else if (age > 75) intensity = 0.6;
                            else if (age > 50) intensity = 0.5;
                            else if (age > 25) intensity = 0.3;
                            else if (age > 10) intensity = 0.2;
                            else intensity = 0.1;
                        } else {
                            intensity = 0.1; // Default low intensity for unknown age
                        }
                    }

                    // Valid intensity values are typically between 0 and 1
                    intensity = Math.min(1, Math.max(0.1, intensity));

                    heatPoints.push([coords[1], coords[0], intensity]);
                });

                // Create the heat layer
                const heatLayer = L.heatLayer(heatPoints, {
                    radius: 15, // Size of each heat point
                    blur: 20, // Blur radius
                    maxZoom: 17, // Zoom level where heat turns to dots
                    max: 1.0, // Max intensity
                    gradient: {
                        // Color gradient based on current mode - matches legend colors
                        0.1:
                            currentMode === "distance"
                                ? "#d73027" // Farthest from transit (red)
                                : currentMode === "modes"
                                ? "#deebf7" // Least transit modes (light blue)
                                : "#fee5d9", // Newest buildings (light pink)
                        0.3:
                            currentMode === "distance"
                                ? "#fdae61"
                                : currentMode === "modes"
                                ? "#9ecae1"
                                : "#fcbba1",
                        0.5:
                            currentMode === "distance"
                                ? "#fee08b"
                                : currentMode === "modes"
                                ? "#6baed6"
                                : "#fc9272",
                        0.7:
                            currentMode === "distance"
                                ? "#a6d96a"
                                : currentMode === "modes"
                                ? "#3182bd"
                                : "#cb181d",
                        1.0:
                            currentMode === "distance"
                                ? "#1a9850" // Closest to transit (green)
                                : currentMode === "modes"
                                ? "#08519c" // Most transit modes (dark blue)
                                : "#67000d", // Oldest buildings (dark red)
                    },
                });

                return heatLayer;
            }

            // Render heatmap
            function renderHeatmap() {
                if (heatmapLayer) map.removeLayer(heatmapLayer);
                heatmapLayer = createHeatmapLayer();
                heatmapLayer.addTo(map);

                // Update points count for heatmap
                const pointsCountElement =
                    document.getElementById("points-count");
                pointsCountElement.textContent = `Heat map visualization of ${geoJsonData.features.length.toLocaleString()} points`;
            }

            // Create custom canvas layer for maximum performance
            function createCustomCanvasLayer(mode) {
                if (
                    !geoJsonData ||
                    !geoJsonData.features ||
                    geoJsonData.features.length === 0
                )
                    return null;

                // Filter and sample data if needed
                let features;
                if (mode === "age") {
                    // Filter buildings with year data
                    features = geoJsonData.features.filter(
                        (feature) =>
                            feature.properties.year_built &&
                            !isNaN(feature.properties.year_built)
                    );

                    if (features.length === 0) {
                        alert("No building age data available for this city");
                        return null;
                    }
                } else {
                    features = geoJsonData.features;
                }

                // Apply sampling if needed (for very large datasets)
                if (useSampling && features.length > 5000) {
                    const targetCount = Math.max(
                        5000,
                        Math.floor(features.length * samplingRate)
                    );
                    const step = Math.floor(features.length / targetCount);
                    features = features.filter(
                        (_, index) => index % step === 0
                    );
                }

                // Configure color and radius functions based on mode
                const colorFunction = (feature) => {
                    if (mode === "distance") {
                        return getDistanceColor(
                            feature.properties.transit_distance
                        );
                    } else if (mode === "modes") {
                        return getModesColor(feature.properties.transit_modes);
                    } else if (mode === "age") {
                        return getAgeColor(feature.properties.year_built);
                    }
                    return "#cccccc";
                };

                const radiusFunction = (feature) => {
                    return 4; // Fixed radius or you can make it dynamic based on zoom
                };

                // Create and return the canvas overlay
                const canvasLayer = new CanvasOverlay({
                    data: features,
                    colorFunction: colorFunction,
                    radiusFunction: radiusFunction,
                    onClick: (feature) => {
                        // Show a popup with feature info
                        const coords = feature.geometry.coordinates;
                        const latlng = L.latLng(coords[1], coords[0]);

                        let html = `<b>Distance to transit:</b> ${Math.round(
                            feature.properties.transit_distance
                        )} meters<br />`;
                        html += `<b>Transit modes within 100m:</b> ${feature.properties.transit_modes}<br />`;

                        if (
                            feature.properties.year_built &&
                            !isNaN(feature.properties.year_built)
                        ) {
                            html += `<b>Built:</b> ${
                                feature.properties.year_built
                            } (${
                                new Date().getFullYear() -
                                feature.properties.year_built
                            } years old)<br />`;
                        }

                        if (feature.properties.green_distance) {
                            html += `<b>Distance to green space:</b> ${Math.round(
                                feature.properties.green_distance
                            )} meters<br />`;
                        }

                        L.popup()
                            .setLatLng(latlng)
                            .setContent(html)
                            .openOn(map);
                    },
                    onHover: (feature) => {
                        // Update the info control
                        if (feature) {
                            info.update(feature.properties);
                        } else {
                            info.update();
                        }
                    },
                });

                return canvasLayer;
            }

            // Create transit stops layer
            function createTransitStopsLayer() {
                if (
                    !transitPointsData ||
                    !transitPointsData.points ||
                    transitPointsData.points.length === 0
                )
                    return;

                if (stopsLayer) map.removeLayer(stopsLayer);

                const stopsGeoJson = {
                    type: "FeatureCollection",
                    features: transitPointsData.points.map((point) => ({
                        type: "Feature",
                        geometry: {
                            type: "Point",
                            coordinates: point.coords,
                        },
                        properties: {
                            type: point.type,
                        },
                    })),
                };

                // Create the stops layer
                stopsLayer = L.geoJSON(stopsGeoJson, {
                    pointToLayer: function (feature, latlng) {
                        // Different colors for different transit types
                        const color =
                            feature.properties.type === "subway"
                                ? "#D81B60"
                                : feature.properties.type === "bus"
                                ? "#1976D2"
                                : feature.properties.type === "tram"
                                ? "#388E3C"
                                : "#FFC107";

                        return L.circleMarker(latlng, {
                            radius: 6,
                            fillColor: color,
                            color: "white",
                            weight: 2,
                            opacity: 1,
                            fillOpacity: 0.9,
                        });
                    },
                    onEachFeature: function (feature, layer) {
                        layer.bindPopup(
                            `<b>${feature.properties.type.toUpperCase()} Stop</b>`
                        );
                    },
                }).addTo(map);

                toggleStops(); // Apply the current checkbox state
            }

            // Toggle transit stops visibility
            function toggleStops() {
                if (!stopsLayer) return;

                if (document.getElementById("show-stops").checked) {
                    map.addLayer(stopsLayer);
                } else {
                    map.removeLayer(stopsLayer);
                }
            }

            // Toggle building age visualization
            function toggleBuildingAge() {
                if (document.getElementById("show-age").checked) {
                    toggleMode("age");
                } else {
                    toggleMode("distance");
                }
            }

            // No view mode toggle needed as we only use dot view

            // Set up re-rendering on map movement events to update viewport filtering
            function setupMapMoveEvents() {
                map.on("moveend", function () {
                    if (
                        useViewportFiltering &&
                        !useDataClustering &&
                        !useCustomCanvasRenderer
                    ) {
                        toggleMode(currentMode);
                    }
                });
            }

            // Setup map events for custom canvas
            function setupMapEventsForCustomCanvas() {
                map.on("zoomend", function () {
                    if (customCanvasLayer && customCanvasLayer._map) {
                        customCanvasLayer._reset();
                    }
                });

                map.on("moveend", function () {
                    if (customCanvasLayer && customCanvasLayer._map) {
                        customCanvasLayer._reset();
                    }
                });
            }

            // Setup map click handler
            function setupMapClickHandler() {
                map.off("click"); // Remove existing handlers

                map.on("click", function (e) {
                    if (!geoJsonData || !geoJsonData.features) return;

                    // Only handle clicks if not using custom canvas renderer
                    if (useCustomCanvasRenderer) return;

                    // Find the nearest building to the click location
                    let minDist = Infinity;
                    let nearestBuilding = null;

                    geoJsonData.features.forEach((feature) => {
                        const coords = feature.geometry.coordinates;
                        const latlng = L.latLng(coords[1], coords[0]);
                        const distance = e.latlng.distanceTo(latlng);

                        if (distance < minDist) {
                            minDist = distance;
                            nearestBuilding = feature;
                        }
                    });

                    // If within 100 meters of a building, show its info
                    if (minDist < 100 && nearestBuilding) {
                        info.update(nearestBuilding.properties);
                    }
                });
            }

            // Display city metrics
            function displayCityMetrics() {
                const cityMetricsElement =
                    document.getElementById("city-metrics");

                if (
                    !geoJsonData ||
                    !geoJsonData.features ||
                    geoJsonData.features.length === 0
                ) {
                    cityMetricsElement.innerHTML =
                        "<p class='text-center text-gray-400'>No city metrics data available</p>";
                    return;
                }

                // Prepare transit points distribution
                let transitDistribution = "";
                if (transitPointsData && transitPointsData.typeCounts) {
                    transitDistribution = Object.entries(
                        transitPointsData.typeCounts
                    )
                        .map(
                            ([type, count]) => `
                            <div>${
                                type.charAt(0).toUpperCase() + type.slice(1)
                            }:</div>
                            <div class="text-right font-medium">${count}</div>
                        `
                        )
                        .join("");
                }

                // If we have city metrics from the JSON file, use those values
                if (cityMetricsData) {
                    // Create the metrics HTML using the city-level metrics JSON
                    cityMetricsElement.innerHTML = `
                        <div class="grid grid-cols-2 gap-2 text-sm">
                            <div>Total buildings:</div>
                            <div class="text-right font-medium">${cityMetricsData.total_buildings.toLocaleString()}</div>
                            <div>Total transit points:</div>
                            <div class="text-right font-medium">${
                                transitPointsData
                                    ? transitPointsData.totalCount
                                    : "N/A"
                            }</div>
                        </div>
                        
                        <div class="mt-3 pt-3 border-t border-gray-200">
                            <h3 class="font-bold text-gray-700 mb-2">Transit Points Distribution</h3>
                            <div class="grid grid-cols-2 gap-2 text-sm">
                                ${transitDistribution}
                            </div>
                        </div>
                        
                        <div class="mt-3 pt-3 border-t border-gray-200">
                            <h3 class="font-bold text-gray-700 mb-2">Urban Form</h3>
                            <div class="grid grid-cols-2 gap-2 text-sm">
                                <div>Average distance to transit:</div>
                                <div class="text-right font-medium">${Math.round(
                                    cityMetricsData.avg_transport_distance
                                )} meters</div>
                                
                                ${
                                    cityMetricsData.green_space_ratio !==
                                    undefined
                                        ? `
                                <div>Green cover percentage:</div>
                                <div class="text-right font-medium">${(
                                    cityMetricsData.green_space_ratio * 100 || 0
                                ).toFixed(1)}%</div>`
                                        : ""
                                }
                                
                                ${
                                    cityMetricsData.building_to_street_ratio !==
                                    undefined
                                        ? `
                                <div>Building-to-street ratio:</div>
                                <div class="text-right font-medium">${cityMetricsData.building_to_street_ratio.toFixed(
                                    2
                                )}</div>`
                                        : ""
                                }
                            </div>
                        </div>
                    `;
                } else {
                    // Fallback to calculating metrics from GeoJSON if city metrics file not available
                    const totalBuildings = geoJsonData.features.length;

                    // Calculate transport metrics
                    const avgDistance =
                        geoJsonData.features.reduce(
                            (sum, b) => sum + b.properties.transit_distance,
                            0
                        ) / totalBuildings;
                    const buildingsNearTransit = geoJsonData.features.filter(
                        (b) => b.properties.transit_modes > 0
                    ).length;
                    const transitAccessPercent = Math.round(
                        (buildingsNearTransit / totalBuildings) * 100
                    );

                    // Calculate green space metrics if available
                    let greenSpaceStats = "";
                    let greenCoverPct = "N/A";
                    if (geoJsonData.features[0].properties.green_distance) {
                        const buildingsNearGreen = geoJsonData.features.filter(
                            (b) => b.properties.nearby_green_area > 0
                        ).length;
                        const greenAccessPercent = Math.round(
                            (buildingsNearGreen / totalBuildings) * 100
                        );

                        // Estimate green cover from nearby_green_area if available
                        if (
                            geoJsonData.features[0].properties
                                .nearby_green_area !== undefined
                        ) {
                            const totalArea = geoJsonData.features.reduce(
                                (sum, b) =>
                                    sum + (b.properties.nearby_green_area || 0),
                                0
                            );
                            greenCoverPct = (
                                (totalArea / (totalBuildings * 10000)) *
                                100
                            ).toFixed(1);
                        }

                        greenSpaceStats = `
                            <div class="mt-3 pt-3 border-t border-gray-200">
                                <h3 class="font-bold text-gray-700 mb-2">Green Space</h3>
                                <div class="grid grid-cols-2 gap-2 text-sm">
                                    <div>Green cover percentage:</div>
                                    <div class="text-right font-medium">${greenCoverPct}%</div>
                                    <div>Buildings near green space:</div>
                                    <div class="text-right font-medium">${greenAccessPercent}%</div>
                                </div>
                            </div>
                        `;
                    }

                    // Create the metrics HTML
                    cityMetricsElement.innerHTML = `
                        <div class="grid grid-cols-2 gap-2 text-sm">
                            <div>Total buildings:</div>
                            <div class="text-right font-medium">${totalBuildings.toLocaleString()}</div>
                            <div>Total transit points:</div>
                            <div class="text-right font-medium">${
                                transitPointsData
                                    ? transitPointsData.totalCount
                                    : "N/A"
                            }</div>
                        </div>
                        
                        <div class="mt-3 pt-3 border-t border-gray-200">
                            <h3 class="font-bold text-gray-700 mb-2">Transit Points Distribution</h3>
                            <div class="grid grid-cols-2 gap-2 text-sm">
                                ${transitDistribution}
                            </div>
                        </div>
                        
                        <div class="mt-3 pt-3 border-t border-gray-200">
                            <h3 class="font-bold text-gray-700 mb-2">Urban Form</h3>
                            <div class="grid grid-cols-2 gap-2 text-sm">
                                <div>Average distance to transit:</div>
                                <div class="text-right font-medium">${Math.round(
                                    avgDistance
                                )} meters</div>
                                <div>Green cover percentage:</div>
                                <div class="text-right font-medium">${greenCoverPct}%</div>
                                <div>Building-to-street ratio:</div>
                                <div class="text-right font-medium">N/A</div>
                            </div>
                        </div>
                    `;
                }

                // Create the charts
                createTransitChart();
                createModeChart();
                createAgeChart();
            }

            // Create transit accessibility chart
            function createTransitChart() {
                if (
                    !geoJsonData ||
                    !geoJsonData.features ||
                    geoJsonData.features.length === 0
                )
                    return;

                const canvas = document.getElementById("transit-chart");
                const ctx = canvas.getContext("2d");

                // Calculate distance buckets
                const distanceBuckets = {
                    "< 100m": 0,
                    "100-300m": 0,
                    "300-600m": 0,
                    "600-1000m": 0,
                    "> 1000m": 0,
                };

                // Make sure transit_distance is a number
                geoJsonData.features.forEach((feature) => {
                    // Changed from transport_distance to transit_distance
                    const distance = parseFloat(
                        feature.properties.transit_distance
                    );

                    // Skip invalid values
                    if (isNaN(distance)) return;

                    if (distance < 100) distanceBuckets["< 100m"]++;
                    else if (distance < 300) distanceBuckets["100-300m"]++;
                    else if (distance < 600) distanceBuckets["300-600m"]++;
                    else if (distance < 1000) distanceBuckets["600-1000m"]++;
                    else distanceBuckets["> 1000m"]++;
                });

                // Create chart
                if (window.transitChart) window.transitChart.destroy();

                window.transitChart = new Chart(ctx, {
                    type: "bar",
                    data: {
                        labels: Object.keys(distanceBuckets),
                        datasets: [
                            {
                                label: "Buildings",
                                data: Object.values(distanceBuckets),
                                backgroundColor: [
                                    "#1a9850",
                                    "#a6d96a",
                                    "#fee08b",
                                    "#fdae61",
                                    "#d73027",
                                ],
                                borderWidth: 1,
                            },
                        ],
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            title: { display: false },
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: "Number of Buildings",
                                },
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: "Distance to Transit",
                                },
                            },
                        },
                    },
                });
            }

            // Create mode distribution chart
            function createModeChart() {
                if (
                    !geoJsonData ||
                    !geoJsonData.features ||
                    geoJsonData.features.length === 0
                )
                    return;

                const canvas = document.getElementById("mode-chart");
                const ctx = canvas.getContext("2d");

                // Calculate mode buckets
                const modeBuckets = {
                    "No transit": 0,
                    "1 mode": 0,
                    "2 modes": 0,
                    "3 modes": 0,
                    "4+ modes": 0,
                };

                geoJsonData.features.forEach((feature) => {
                    const modes = feature.properties.transit_modes;
                    if (modes === 0) modeBuckets["No transit"]++;
                    else if (modes === 1) modeBuckets["1 mode"]++;
                    else if (modes === 2) modeBuckets["2 modes"]++;
                    else if (modes === 3) modeBuckets["3 modes"]++;
                    else modeBuckets["4+ modes"]++;
                });

                // Create chart
                if (window.modeChart) window.modeChart.destroy();

                window.modeChart = new Chart(ctx, {
                    type: "pie",
                    data: {
                        labels: Object.keys(modeBuckets),
                        datasets: [
                            {
                                data: Object.values(modeBuckets),
                                backgroundColor: [
                                    "#deebf7",
                                    "#9ecae1",
                                    "#6baed6",
                                    "#3182bd",
                                    "#08519c",
                                ],
                                borderWidth: 1,
                            },
                        ],
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { position: "right" },
                        },
                    },
                });
            }

            // Create age distribution chart
            function createAgeChart() {
                const canvas = document.getElementById("age-chart");
                const ctx = canvas.getContext("2d");

                if (!ageDistributionData || ageDistributionData.length === 0) {
                    if (window.ageChart) window.ageChart.destroy();
                    return;
                }

                // Sort age periods chronologically
                const periodOrder = [
                    "Pre-1800",
                    "1800-1849",
                    "1850-1899",
                    "1900-1944",
                    "1945-1969",
                    "1970-1989",
                    "1990-1999",
                    "2000-2009",
                    "2010-present",
                    "Unknown",
                ];

                const sortedData = [...ageDistributionData].sort((a, b) => {
                    return (
                        periodOrder.indexOf(a.age_period) -
                        periodOrder.indexOf(b.age_period)
                    );
                });

                // Filter out "Unknown" for the chart
                const chartData = sortedData.filter(
                    (item) => item.age_period !== "Unknown"
                );

                // Create color gradient based on age
                const backgroundColors = chartData.map((item) => {
                    const period = item.age_period;
                    if (period === "Pre-1800") return "#67000d";
                    if (period === "1800-1849") return "#a50f15";
                    if (period === "1850-1899") return "#cb181d";
                    if (period === "1900-1944") return "#ef3b2c";
                    if (period === "1945-1969") return "#fb6a4a";
                    if (period === "1970-1989") return "#fc9272";
                    if (period === "1990-1999") return "#fcbba1";
                    if (period === "2000-2009") return "#fee0d2";
                    return "#fee5d9";
                });

                // Create chart
                if (window.ageChart) window.ageChart.destroy();

                window.ageChart = new Chart(ctx, {
                    type: "bar",
                    data: {
                        labels: chartData.map((item) => item.age_period),
                        datasets: [
                            {
                                label: "Buildings",
                                data: chartData.map((item) => item.count),
                                backgroundColor: backgroundColors,
                                borderWidth: 1,
                            },
                        ],
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        indexAxis: "y",
                        plugins: {
                            legend: { display: false },
                        },
                        scales: {
                            x: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: "Number of Buildings",
                                },
                            },
                        },
                    },
                });
            }

            // Set up event listeners
            function setupEventListeners() {
                document
                    .getElementById("distance-btn")
                    .addEventListener("click", () => {
                        document.getElementById("show-age").checked = false;
                        toggleMode("distance");
                    });

                document
                    .getElementById("modes-btn")
                    .addEventListener("click", () => {
                        document.getElementById("show-age").checked = false;
                        toggleMode("modes");
                    });

                document
                    .getElementById("show-stops")
                    .addEventListener("change", toggleStops);
                document
                    .getElementById("show-age")
                    .addEventListener("change", toggleBuildingAge);
            }
        </script>
    </body>
</html>
